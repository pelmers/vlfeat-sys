#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
extern crate libc;

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const VL_OS_MACOSX: ::std::os::raw::c_uint = 1;
pub const VL_THREADS_POSIX: ::std::os::raw::c_uint = 1;
pub const VL_TRUE: ::std::os::raw::c_uint = 1;
pub const VL_FALSE: ::std::os::raw::c_uint = 0;
pub const VL_FL_INT64: &'static [u8; 3usize] = b"ll\x00";
pub const VL_FL_INT32: &'static [u8; 1usize] = b"\x00";
pub const VL_FL_INT16: &'static [u8; 2usize] = b"h\x00";
pub const VL_FL_INT8: &'static [u8; 3usize] = b"hh\x00";
pub const VL_FL_INDEX: &'static [u8; 3usize] = b"ll\x00";
pub const VL_FMT_INDEX: &'static [u8; 4usize] = b"lld\x00";
pub const VL_FMT_INTPTR: &'static [u8; 4usize] = b"lld\x00";
pub const VL_FMT_UINDEX: &'static [u8; 4usize] = b"llu\x00";
pub const VL_FMT_SIZE: &'static [u8; 4usize] = b"llu\x00";
pub const VL_FMT_UINTPTR: &'static [u8; 4usize] = b"llu\x00";
pub const VL_BIG_INT: ::std::os::raw::c_uint = 2147483647;
pub const VL_SMALL_INT: ::std::os::raw::c_int = -2147483648;
pub const VL_BIG_UINT: ::std::os::raw::c_uint = 4294967295;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101104;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const __DARWIN_NSIG: ::std::os::raw::c_uint = 32;
pub const NSIG: ::std::os::raw::c_uint = 32;
pub const _I386_SIGNAL_H_: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGEMT: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGINFO: ::std::os::raw::c_uint = 29;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 3;
pub const ILL_NOOP: ::std::os::raw::c_uint = 0;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 2;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 3;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 4;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const FPE_NOOP: ::std::os::raw::c_uint = 0;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 3;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 4;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 5;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 6;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 7;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 8;
pub const SEGV_NOOP: ::std::os::raw::c_uint = 0;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const BUS_NOOP: ::std::os::raw::c_uint = 0;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const TRAP_BRKPT: ::std::os::raw::c_uint = 1;
pub const TRAP_TRACE: ::std::os::raw::c_uint = 2;
pub const CLD_NOOP: ::std::os::raw::c_uint = 0;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SA_RESTART: ::std::os::raw::c_uint = 2;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SA_NODEFER: ::std::os::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 32;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 64;
pub const SA_USERTRAMP: ::std::os::raw::c_uint = 256;
pub const SA_64REGSET: ::std::os::raw::c_uint = 512;
pub const SA_USERSPACE_MASK: ::std::os::raw::c_uint = 127;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 2;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 3;
pub const SI_USER: ::std::os::raw::c_uint = 65537;
pub const SI_QUEUE: ::std::os::raw::c_uint = 65538;
pub const SI_TIMER: ::std::os::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::std::os::raw::c_uint = 65540;
pub const SI_MESGQ: ::std::os::raw::c_uint = 65541;
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 32768;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 131072;
pub const SV_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SV_INTERRUPT: ::std::os::raw::c_uint = 2;
pub const SV_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SV_NODEFER: ::std::os::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SV_SIGINFO: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const PRIO_DARWIN_THREAD: ::std::os::raw::c_uint = 3;
pub const PRIO_DARWIN_PROCESS: ::std::os::raw::c_uint = 4;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const PRIO_DARWIN_NONUI: ::std::os::raw::c_uint = 4097;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_INFO_V0: ::std::os::raw::c_uint = 0;
pub const RUSAGE_INFO_V1: ::std::os::raw::c_uint = 1;
pub const RUSAGE_INFO_V2: ::std::os::raw::c_uint = 2;
pub const RUSAGE_INFO_V3: ::std::os::raw::c_uint = 3;
pub const RUSAGE_INFO_CURRENT: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 9;
pub const _RLIMIT_POSIX_FLAG: ::std::os::raw::c_uint = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: ::std::os::raw::c_uint = 2;
pub const RLIMIT_THREAD_CPULIMITS: ::std::os::raw::c_uint = 3;
pub const WAKEMON_ENABLE: ::std::os::raw::c_uint = 1;
pub const WAKEMON_DISABLE: ::std::os::raw::c_uint = 2;
pub const WAKEMON_GET_PARAMS: ::std::os::raw::c_uint = 4;
pub const WAKEMON_SET_DEFAULTS: ::std::os::raw::c_uint = 8;
pub const WAKEMON_MAKE_FATAL: ::std::os::raw::c_uint = 16;
pub const CPUMON_MAKE_FATAL: ::std::os::raw::c_uint = 4096;
pub const IOPOL_TYPE_DISK: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_PROCESS: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_THREAD: ::std::os::raw::c_uint = 1;
pub const IOPOL_SCOPE_DARWIN_BG: ::std::os::raw::c_uint = 2;
pub const IOPOL_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_IMPORTANT: ::std::os::raw::c_uint = 1;
pub const IOPOL_PASSIVE: ::std::os::raw::c_uint = 2;
pub const IOPOL_THROTTLE: ::std::os::raw::c_uint = 3;
pub const IOPOL_UTILITY: ::std::os::raw::c_uint = 4;
pub const IOPOL_STANDARD: ::std::os::raw::c_uint = 5;
pub const IOPOL_APPLICATION: ::std::os::raw::c_uint = 5;
pub const IOPOL_NORMAL: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _WSTOPPED: ::std::os::raw::c_uint = 127;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WSTOPPED: ::std::os::raw::c_uint = 8;
pub const WCONTINUED: ::std::os::raw::c_uint = 16;
pub const WNOWAIT: ::std::os::raw::c_uint = 32;
pub const WAIT_ANY: ::std::os::raw::c_int = -1;
pub const WAIT_MYPGRP: ::std::os::raw::c_uint = 0;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const CLOCKS_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const VL_VERSION_STRING: &'static [u8; 7usize] = b"0.9.20\x00";
pub const VL_ERR_MSG_LEN: ::std::os::raw::c_uint = 1024;
pub const VL_TYPE_FLOAT: ::std::os::raw::c_uint = 1;
pub const VL_TYPE_DOUBLE: ::std::os::raw::c_uint = 2;
pub const VL_TYPE_INT8: ::std::os::raw::c_uint = 3;
pub const VL_TYPE_UINT8: ::std::os::raw::c_uint = 4;
pub const VL_TYPE_INT16: ::std::os::raw::c_uint = 5;
pub const VL_TYPE_UINT16: ::std::os::raw::c_uint = 6;
pub const VL_TYPE_INT32: ::std::os::raw::c_uint = 7;
pub const VL_TYPE_UINT32: ::std::os::raw::c_uint = 8;
pub const VL_TYPE_INT64: ::std::os::raw::c_uint = 9;
pub const VL_TYPE_UINT64: ::std::os::raw::c_uint = 10;
pub const VL_ERR_OK: ::std::os::raw::c_uint = 0;
pub const VL_ERR_OVERFLOW: ::std::os::raw::c_uint = 1;
pub const VL_ERR_ALLOC: ::std::os::raw::c_uint = 2;
pub const VL_ERR_BAD_ARG: ::std::os::raw::c_uint = 3;
pub const VL_ERR_IO: ::std::os::raw::c_uint = 4;
pub const VL_ERR_EOF: ::std::os::raw::c_uint = 5;
pub const VL_ERR_NO_MORE: ::std::os::raw::c_uint = 5;
pub const FP_NAN: ::std::os::raw::c_uint = 1;
pub const FP_INFINITE: ::std::os::raw::c_uint = 2;
pub const FP_ZERO: ::std::os::raw::c_uint = 3;
pub const FP_NORMAL: ::std::os::raw::c_uint = 4;
pub const FP_SUBNORMAL: ::std::os::raw::c_uint = 5;
pub const FP_SUPERNORMAL: ::std::os::raw::c_uint = 6;
pub const FP_ILOGB0: ::std::os::raw::c_int = -2147483648;
pub const FP_ILOGBNAN: ::std::os::raw::c_int = -2147483648;
pub const MATH_ERRNO: ::std::os::raw::c_uint = 1;
pub const MATH_ERREXCEPT: ::std::os::raw::c_uint = 2;
pub const M_E: f32 = 2.718281828459045;
pub const M_LOG2E: f32 = 1.4426950408889634;
pub const M_LOG10E: f32 = 0.4342944819032518;
pub const M_LN2: f32 = 0.6931471805599453;
pub const M_LN10: f32 = 2.302585092994046;
pub const M_PI: f32 = 3.141592653589793;
pub const M_PI_2: f32 = 1.5707963267948966;
pub const M_PI_4: f32 = 0.7853981633974483;
pub const M_1_PI: f32 = 0.3183098861837907;
pub const M_2_PI: f32 = 0.6366197723675814;
pub const M_2_SQRTPI: f32 = 1.1283791670955126;
pub const M_SQRT2: f32 = 1.4142135623730951;
pub const M_SQRT1_2: f32 = 0.7071067811865476;
pub const FP_SNAN: ::std::os::raw::c_uint = 1;
pub const FP_QNAN: ::std::os::raw::c_uint = 1;
pub const DOMAIN: ::std::os::raw::c_uint = 1;
pub const SING: ::std::os::raw::c_uint = 2;
pub const OVERFLOW: ::std::os::raw::c_uint = 3;
pub const UNDERFLOW: ::std::os::raw::c_uint = 4;
pub const TLOSS: ::std::os::raw::c_uint = 5;
pub const PLOSS: ::std::os::raw::c_uint = 6;
pub const VL_E: f32 = 2.718281828459045;
pub const VL_LOG_OF_2: f32 = 0.693147180559945;
pub const VL_PI: f32 = 3.141592653589793;
pub const VL_ARRAY_MAX_NUM_DIMENSIONS: ::std::os::raw::c_uint = 16;
pub const VL_PAD_BY_ZERO: ::std::os::raw::c_uint = 0;
pub const VL_PAD_BY_CONTINUITY: ::std::os::raw::c_uint = 1;
pub const VL_PAD_MASK: ::std::os::raw::c_uint = 3;
pub const VL_TRANSPOSE: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const VL_FISHER_FLAG_SQUARE_ROOT: ::std::os::raw::c_uint = 1;
pub const VL_FISHER_FLAG_NORMALIZED: ::std::os::raw::c_uint = 2;
pub const VL_FISHER_FLAG_IMPROVED: ::std::os::raw::c_uint = 3;
pub const VL_FISHER_FLAG_FAST: ::std::os::raw::c_uint = 4;
pub const no_argument: ::std::os::raw::c_uint = 0;
pub const required_argument: ::std::os::raw::c_uint = 1;
pub const optional_argument: ::std::os::raw::c_uint = 2;
pub const VL_KDTREE_SPLIT_HEAP_SIZE: ::std::os::raw::c_uint = 5;
pub const VL_KDTREE_VARIANCE_EST_NUM_SAMPLES: ::std::os::raw::c_uint = 1024;
pub const VL_IKMACC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const FLT: ::std::os::raw::c_uint = 2;
pub const VSIZE: ::std::os::raw::c_uint = 2;
pub const VL_MSER_PIX_MAXVAL: ::std::os::raw::c_uint = 256;
pub const VL_MSER_VOID_NODE: ::std::os::raw::c_uint = 4294967295;
pub const VL_ERR_PGM_INV_HEAD: ::std::os::raw::c_uint = 101;
pub const VL_ERR_PGM_INV_META: ::std::os::raw::c_uint = 102;
pub const VL_ERR_PGM_INV_DATA: ::std::os::raw::c_uint = 103;
pub const VL_ERR_PGM_IO: ::std::os::raw::c_uint = 104;
pub const VL_VLAD_FLAG_NORMALIZE_COMPONENTS: ::std::os::raw::c_uint = 1;
pub const VL_VLAD_FLAG_SQUARE_ROOT: ::std::os::raw::c_uint = 2;
pub const VL_VLAD_FLAG_UNNORMALIZED: ::std::os::raw::c_uint = 4;
pub const VL_VLAD_FLAG_NORMALIZE_MASS: ::std::os::raw::c_uint = 8;
extern "C" {
    pub fn vl_static_configuration_to_string_copy()
     -> *mut ::std::os::raw::c_char;
}
pub type vl_int64 = ::std::os::raw::c_longlong;
pub type vl_int32 = ::std::os::raw::c_int;
pub type vl_int16 = ::std::os::raw::c_short;
pub type vl_int8 = ::std::os::raw::c_char;
pub type vl_uint64 = ::std::os::raw::c_ulonglong;
pub type vl_uint32 = ::std::os::raw::c_uint;
pub type vl_uint16 = ::std::os::raw::c_ushort;
pub type vl_uint8 = ::std::os::raw::c_uchar;
pub type vl_int = ::std::os::raw::c_int;
pub type vl_uint = ::std::os::raw::c_uint;
pub type vl_bool = ::std::os::raw::c_int;
pub type vl_intptr = vl_int64;
pub type vl_uintptr = vl_uint64;
pub type vl_size = vl_uint64;
pub type vl_index = vl_int64;
pub type vl_uindex = vl_uint64;
/** ------------------------------------------------------------------
 ** @name Obtaining host info at run time
 ** @{ */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlX86CpuInfo {
    pub vendor: _VlX86CpuInfo__bindgen_ty_1,
    pub hasAVX: vl_bool,
    pub hasSSE42: vl_bool,
    pub hasSSE41: vl_bool,
    pub hasSSE3: vl_bool,
    pub hasSSE2: vl_bool,
    pub hasSSE: vl_bool,
    pub hasMMX: vl_bool,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlX86CpuInfo__bindgen_ty_1 {
    pub string: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub words: __BindgenUnionField<[vl_uint32; 8usize]>,
    pub bindgen_union_field: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__VlX86CpuInfo__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_VlX86CpuInfo__bindgen_ty_1>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( _VlX86CpuInfo__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_VlX86CpuInfo__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( _VlX86CpuInfo__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo__bindgen_ty_1 ) ) . string
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlX86CpuInfo__bindgen_ty_1 ) , "::" , stringify ! ( string )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo__bindgen_ty_1 ) ) . words
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlX86CpuInfo__bindgen_ty_1 ) , "::" , stringify ! ( words )
                ));
}
impl Clone for _VlX86CpuInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__VlX86CpuInfo() {
    assert_eq!(::std::mem::size_of::<_VlX86CpuInfo>() , 60usize , concat ! (
               "Size of: " , stringify ! ( _VlX86CpuInfo ) ));
    assert_eq! (::std::mem::align_of::<_VlX86CpuInfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _VlX86CpuInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . vendor as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasAVX as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasAVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasSSE42 as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasSSE42 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasSSE41 as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasSSE41 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasSSE3 as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasSSE3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasSSE2 as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasSSE2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasSSE as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasSSE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlX86CpuInfo ) ) . hasMMX as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlX86CpuInfo ) , "::"
                , stringify ! ( hasMMX ) ));
}
impl Clone for _VlX86CpuInfo {
    fn clone(&self) -> Self { *self }
}
pub type VlX86CpuInfo = _VlX86CpuInfo;
extern "C" {
    pub fn _vl_x86cpu_info_init(self_: *mut VlX86CpuInfo);
}
extern "C" {
    pub fn _vl_x86cpu_info_to_string_copy(self_: *const VlX86CpuInfo)
     -> *mut ::std::os::raw::c_char;
}
/** @brief Random numbber generator state */
#[repr(C)]
pub struct _VlRand {
    pub mt: [vl_uint32; 624usize],
    pub mti: vl_uint32,
}
#[test]
fn bindgen_test_layout__VlRand() {
    assert_eq!(::std::mem::size_of::<_VlRand>() , 2500usize , concat ! (
               "Size of: " , stringify ! ( _VlRand ) ));
    assert_eq! (::std::mem::align_of::<_VlRand>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _VlRand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlRand ) ) . mt as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlRand ) , "::" ,
                stringify ! ( mt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlRand ) ) . mti as * const _ as usize }
                , 2496usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlRand ) , "::" ,
                stringify ! ( mti ) ));
}
pub type VlRand = _VlRand;
extern "C" {
    /** @name Setting and reading the state
 **
 ** @{ */
    pub fn vl_rand_init(self_: *mut VlRand);
}
extern "C" {
    pub fn vl_rand_seed(self_: *mut VlRand, s: vl_uint32);
}
extern "C" {
    pub fn vl_rand_seed_by_array(self_: *mut VlRand, key: *const vl_uint32,
                                 keySize: vl_size);
}
extern "C" {
    pub fn vl_rand_uint32(self_: *mut VlRand) -> vl_uint32;
}
extern "C" {
    /** @} */
    pub fn vl_rand_permute_indexes(self_: *mut VlRand, array: *mut vl_index,
                                   size: vl_size);
}
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_thread_state>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_thread_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_thread_state>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_thread_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebx as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ecx as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ecx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edx as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edi as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esi as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esp as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ss as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eflags
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eflags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eip as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __cs as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ds as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __es as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __fs as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __gs as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __gs ) ));
}
impl Clone for __darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_control {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_control>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( __darwin_fp_control ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_control>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_fp_control ) ));
}
impl Clone for __darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_status>() , 2usize , concat !
               ( "Size of: " , stringify ! ( __darwin_fp_status ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_status>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_fp_status ) ));
}
impl Clone for __darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_mmst_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mmst_reg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_rsrv as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_rsrv ) ));
}
impl Clone for __darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_xmm_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_xmm_reg>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_xmm_reg ) ) . __xmm_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_xmm_reg ) ,
                "::" , stringify ! ( __xmm_reg ) ));
}
impl Clone for __darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_float_state>() , 524usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_float_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_float_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_float_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
#[repr(C)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx_state>() , 716usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_avx_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fcw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv1
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ip as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_cs as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv2
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_dp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_dp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ds as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv3
                as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_mxcsr
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm0
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm1
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm2
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm3
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm4
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm5
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm6
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm7
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv4
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh0
                as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh1
                as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh2
                as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh3
                as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh4
                as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh5
                as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh6
                as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh7
                as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh7 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_exception_state>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( __darwin_i386_exception_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_exception_state>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_exception_state
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __cpu
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __cpu )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __err
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __err )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state32>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state32>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state32 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr1 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr2 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr3 as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr4 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr5 as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr6 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr7 as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_thread_state64>() , 168usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_thread_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_thread_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_thread_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rax
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbx
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rcx
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rcx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdx
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdi
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsi
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbp
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsp
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r8 as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r9 as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r10
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r10 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r11
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r11 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r12
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r12 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r13
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r13 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r14
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r14 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r15
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r15 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rip
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) .
                __rflags as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rflags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __cs as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __fs as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __fs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __gs as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __gs )
                ));
}
impl Clone for __darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_float_state64>() , 524usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_float_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_float_state64>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_float_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fcw as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fcw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fsw as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fsw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_ftw as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ftw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fop as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fop
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm8 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm9 as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
#[repr(C)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx_state64>() , 844usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_avx_state64>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm7 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm8
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm9
                as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm15
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh15
                ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_exception_state64>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_exception_state64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_exception_state64>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_exception_state64
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __cpu as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __cpu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __err as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __err
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state64>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr1 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr2 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr3 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr4 as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr5 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr6 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr7 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext32>() , 600usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext32 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __ss as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __fs as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __fs ) ));
}
#[repr(C)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx32>() , 792usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __ss as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __fs as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __fs ) ));
}
#[repr(C)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext64>() , 712usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __ss as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __fs as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __fs ) ));
}
#[repr(C)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx64>() , 1032usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __ss as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __fs as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __fs ) ));
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(::std::mem::size_of::<__darwin_sigaltstack>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_sigaltstack )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_sigaltstack>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_sp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_flags ) ));
}
impl Clone for __darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(::std::mem::size_of::<__darwin_ucontext>() , 56usize , concat !
               ( "Size of: " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (::std::mem::align_of::<__darwin_ucontext>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_onstack as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_sigmask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_stack as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_link as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcontext as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcontext ) ));
}
impl Clone for __darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::std::os::raw::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_function as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_attributes as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_attributes ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::std::mem::size_of::<__siginfo>() , 104usize , concat ! (
               "Size of: " , stringify ! ( __siginfo ) ));
    assert_eq! (::std::mem::align_of::<__siginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_band as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . __pad as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigaction_u {
    pub __sa_handler: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>>,
    pub __sa_sigaction: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                           ::std::os::raw::c_int,
                                                                                       arg2:
                                                                                           *mut __siginfo,
                                                                                       arg3:
                                                                                           *mut ::std::os::raw::c_void)>>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(::std::mem::size_of::<__sigaction_u>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __sigaction_u ) ));
    assert_eq! (::std::mem::align_of::<__sigaction_u>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_sigaction as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_sigaction ) ));
}
impl Clone for __sigaction_u {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 ::std::os::raw::c_int,
                                                             arg4:
                                                                 *mut siginfo_t,
                                                             arg5:
                                                                 *mut ::std::os::raw::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(::std::mem::size_of::<__sigaction>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __sigaction ) ));
    assert_eq! (::std::mem::align_of::<__sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . __sigaction_u as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_tramp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_tramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_mask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_flags as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for __sigaction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
pub type sig_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::std::mem::size_of::<sigvec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigvec ) ));
    assert_eq! (::std::mem::align_of::<sigvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_flags ) ));
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>)
     -> ::std::option::Option<unsafe extern "C" fn()>;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::std::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(::std::mem::size_of::<rusage_info_v0>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
}
impl Clone for rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(::std::mem::size_of::<rusage_info_v1>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
}
impl Clone for rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(::std::mem::size_of::<rusage_info_v2>() , 160usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
}
impl Clone for rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(::std::mem::size_of::<rusage_info_v3>() , 232usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_default as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_maintenance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_background as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_utility as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_utility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_legacy as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_legacy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_initiated as * const _ as usize } ,
                200usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_initiated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_interactive as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_interactive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_billed_system_time as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_billed_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_serviced_system_time as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_serviced_system_time ) ));
}
impl Clone for rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_current = rusage_info_v3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::std::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(::std::mem::size_of::<proc_rlimit_control_wakeupmon>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( proc_rlimit_control_wakeupmon ) ));
    assert_eq! (::std::mem::align_of::<proc_rlimit_control_wakeupmon>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( proc_rlimit_control_wakeupmon
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! (
                wm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_rate as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! ( wm_rate
                ) ));
}
impl Clone for proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(arg1: ::std::os::raw::c_int, arg2: id_t,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub w_T: __BindgenUnionField<wait__bindgen_ty_1>,
    pub w_S: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_T as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_T ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_S as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_S ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                 arg3: ::std::os::raw::c_int, arg4: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(arg1: *const ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long)
     -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                  arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(arg1: *mut *mut ::std::os::raw::c_void, arg2: usize,
                          arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(arg1: *mut ::std::os::raw::c_void, arg2: usize, arg3: usize,
                 arg4:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(arg1: *mut ::std::os::raw::c_void, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtol(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const *const ::std::os::raw::c_char,
                     arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(arg1: ::std::os::raw::c_uint,
                     arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "realpath$DARWIN_EXTSN"]
    pub fn realpath(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u_int32_t;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar,
                                arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(arg1: u_int32_t) -> u_int32_t;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(arg1: *const ::std::os::raw::c_void,
                     arg2: *const ::std::os::raw::c_void, arg3: usize,
                     arg4: usize, arg5: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "daemon$1050"]
    pub fn daemon(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(arg1: dev_t, arg2: mode_t,
                     buf: *mut ::std::os::raw::c_char,
                     len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                    arg3: usize,
                    arg4:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                      arg3: usize, arg4: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                     arg3: usize,
                     arg4:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                       arg3: usize, arg4: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(arg1: *mut ::std::os::raw::c_void, arg2: usize, arg3: usize,
                 arg4:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn psort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn psort_r(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn qsort_r(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn radixsort(arg1: *mut *const ::std::os::raw::c_uchar,
                     arg2: ::std::os::raw::c_int,
                     arg3: *const ::std::os::raw::c_uchar,
                     arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(arg1: *mut *const ::std::os::raw::c_uchar,
                      arg2: ::std::os::raw::c_int,
                      arg3: *const ::std::os::raw::c_uchar,
                      arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(arg1: *mut ::std::os::raw::c_void, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtoq(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type rsize_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, arg4: *const tm)
     -> usize;
}
extern "C" {
    pub fn strptime(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, arg3: *mut tm)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(arg1: *const timespec, arg2: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_rtn(arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char);
}
pub type vl_type = vl_uint32;
extern "C" {
    /** @} */
    pub fn vl_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vl_configuration_to_string_copy() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vl_set_simd_enabled(x: vl_bool);
}
extern "C" {
    pub fn vl_get_simd_enabled() -> vl_bool;
}
extern "C" {
    pub fn vl_cpu_has_avx() -> vl_bool;
}
extern "C" {
    pub fn vl_cpu_has_sse3() -> vl_bool;
}
extern "C" {
    pub fn vl_cpu_has_sse2() -> vl_bool;
}
extern "C" {
    pub fn vl_get_num_cpus() -> vl_size;
}
extern "C" {
    pub fn vl_get_rand() -> *mut VlRand;
}
extern "C" {
    /** @name Multi-thread computations
 ** @{ */
    pub fn vl_get_max_threads() -> vl_size;
}
extern "C" {
    pub fn vl_set_num_threads(n: vl_size);
}
extern "C" {
    pub fn vl_get_thread_limit() -> vl_size;
}
extern "C" {
    pub fn vl_get_last_error() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_get_last_error_message() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vl_set_last_error(error: ::std::os::raw::c_int,
                             errorMessage: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** ------------------------------------------------------------------
 ** @name Memory allocation
 ** @{ */
    pub fn vl_set_alloc_func(malloc_func:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                usize)
                                                           ->
                                                               *mut ::std::os::raw::c_void>,
                             realloc_func:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void,
                                                                            arg2:
                                                                                usize)
                                                           ->
                                                               *mut ::std::os::raw::c_void>,
                             calloc_func:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                usize,
                                                                            arg2:
                                                                                usize)
                                                           ->
                                                               *mut ::std::os::raw::c_void>,
                             free_func:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void)>);
}
extern "C" {
    pub fn vl_malloc(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_realloc(ptr: *mut ::std::os::raw::c_void, n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_calloc(n: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_memalign(n: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_free(ptr: *mut ::std::os::raw::c_void);
}
/** ------------------------------------------------------------------
 ** @name Logging
 ** @{ */
/** @brief Customizable printf function pointer type */
pub type printf_func_t =
    ::std::option::Option<unsafe extern "C" fn(format:
                                                   *const ::std::os::raw::c_char, ...)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn vl_set_printf_func(printf_func: printf_func_t);
}
extern "C" {
    pub fn vl_get_printf_func() -> printf_func_t;
}
extern "C" {
    /** ------------------------------------------------------------------
 ** @name Measuring time
 ** @{
 **/
    pub fn vl_tic();
}
extern "C" {
    pub fn vl_toc() -> f64;
}
extern "C" {
    pub fn vl_get_cpu_time() -> f64;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __inff() -> f32;
}
extern "C" {
    pub fn __inf() -> f64;
}
extern "C" {
    pub fn __infl() -> f64;
}
extern "C" {
    pub fn __nan() -> f32;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(::std::mem::size_of::<__float2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __float2 ) ));
    assert_eq! (::std::mem::align_of::<__float2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __float2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __float2 ) ) . __sinval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __float2 ) , "::" ,
                stringify ! ( __sinval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __float2 ) ) . __cosval as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __float2 ) , "::" ,
                stringify ! ( __cosval ) ));
}
impl Clone for __float2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(::std::mem::size_of::<__double2>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __double2 ) ));
    assert_eq! (::std::mem::align_of::<__double2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __double2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __double2 ) ) . __sinval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __double2 ) , "::" ,
                stringify ! ( __sinval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __double2 ) ) . __cosval as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __double2 ) , "::" ,
                stringify ! ( __cosval ) ));
}
impl Clone for __double2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rinttol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundtol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(::std::mem::size_of::<exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( exception ) ));
    assert_eq! (::std::mem::align_of::<exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for exception {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn matherr(arg1: *mut exception) -> ::std::os::raw::c_int;
}
/** @internal @brief IEEE single precision quiet NaN constant */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub raw: __BindgenUnionField<vl_uint32>,
    pub value: __BindgenUnionField<f32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 4usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_1>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_1 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_1 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_1 ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_1 ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vl_nan_f"]
    pub static vl_nan_f: _bindgen_ty_1;
}
/** @internal @brief IEEE single precision infinity constant */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub raw: __BindgenUnionField<vl_uint32>,
    pub value: __BindgenUnionField<f32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 4usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_2 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2 ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_2 ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vl_infinity_f"]
    pub static vl_infinity_f: _bindgen_ty_2;
}
/** @internal @brief IEEE double precision quiet NaN constant */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub raw: __BindgenUnionField<vl_uint64>,
    pub value: __BindgenUnionField<f64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_3 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_3 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_3 ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_3 ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vl_nan_d"]
    pub static vl_nan_d: _bindgen_ty_3;
}
/** @internal @brief IEEE double precision infinity constant */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub raw: __BindgenUnionField<vl_uint64>,
    pub value: __BindgenUnionField<f64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_4>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_4 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_4 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_4 ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_4 ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vl_infinity_d"]
    pub static vl_infinity_d: _bindgen_ty_4;
}
/** @typedef VlFloatVectorComparisonFunction
 ** @brief Pointer to a function to compare vectors of floats
 **/
pub type VlFloatVectorComparisonFunction =
    ::std::option::Option<unsafe extern "C" fn(dimension: vl_size,
                                               X: *const f32, Y: *const f32)
                              -> f32>;
/** @typedef VlDoubleVectorComparisonFunction
 ** @brief Pointer to a function to compare vectors of doubles
 **/
pub type VlDoubleVectorComparisonFunction =
    ::std::option::Option<unsafe extern "C" fn(dimension: vl_size,
                                               X: *const f64, Y: *const f64)
                              -> f64>;
/** @typedef VlFloatVector3ComparisonFunction
 ** @brief Pointer to a function to compare 3 vectors of doubles
 **/
pub type VlFloatVector3ComparisonFunction =
    ::std::option::Option<unsafe extern "C" fn(dimension: vl_size,
                                               X: *const f32, Y: *const f32,
                                               Z: *const f32) -> f32>;
/** @typedef VlDoubleVector3ComparisonFunction
 ** @brief Pointer to a function to compare 3 vectors of doubles
 **/
pub type VlDoubleVector3ComparisonFunction =
    ::std::option::Option<unsafe extern "C" fn(dimension: vl_size,
                                               X: *const f64, Y: *const f64,
                                               Z: *const f64) -> f64>;
#[repr(u32)]
/** @brief Vector comparison types */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlVectorComparisonType {
    VlDistanceL1 = 0,
    VlDistanceL2 = 1,
    VlDistanceChi2 = 2,
    VlDistanceHellinger = 3,
    VlDistanceJS = 4,
    VlDistanceMahalanobis = 5,
    VlKernelL1 = 6,
    VlKernelL2 = 7,
    VlKernelChi2 = 8,
    VlKernelHellinger = 9,
    VlKernelJS = 10,
}
/** @brief Vector comparison types */
pub use self::_VlVectorComparisonType as VlVectorComparisonType;
extern "C" {
    pub fn vl_get_vector_comparison_function_f(type_: VlVectorComparisonType)
     -> VlFloatVectorComparisonFunction;
}
extern "C" {
    pub fn vl_get_vector_comparison_function_d(type_: VlVectorComparisonType)
     -> VlDoubleVectorComparisonFunction;
}
extern "C" {
    pub fn vl_get_vector_3_comparison_function_f(type_:
                                                     VlVectorComparisonType)
     -> VlFloatVector3ComparisonFunction;
}
extern "C" {
    pub fn vl_get_vector_3_comparison_function_d(type_:
                                                     VlVectorComparisonType)
     -> VlDoubleVector3ComparisonFunction;
}
extern "C" {
    pub fn vl_eval_vector_comparison_on_all_pairs_f(result: *mut f32,
                                                    dimension: vl_size,
                                                    X: *const f32,
                                                    numDataX: vl_size,
                                                    Y: *const f32,
                                                    numDataY: vl_size,
                                                    function:
                                                        VlFloatVectorComparisonFunction);
}
extern "C" {
    pub fn vl_eval_vector_comparison_on_all_pairs_d(result: *mut f64,
                                                    dimension: vl_size,
                                                    X: *const f64,
                                                    numDataX: vl_size,
                                                    Y: *const f64,
                                                    numDataY: vl_size,
                                                    function:
                                                        VlDoubleVectorComparisonFunction);
}
extern "C" {
    pub fn vl_svd2(S: *mut f64, U: *mut f64, V: *mut f64, M: *const f64);
}
extern "C" {
    pub fn vl_lapack_dlasv2(smin: *mut f64, smax: *mut f64, sv: *mut f64,
                            cv: *mut f64, su: *mut f64, cu: *mut f64, f: f64,
                            g: f64, h: f64);
}
extern "C" {
    pub fn vl_solve_linear_system_3(x: *mut f64, A: *const f64, b: *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_solve_linear_system_2(x: *mut f64, A: *const f64, b: *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_gaussian_elimination(A: *mut f64, numRows: vl_size,
                                   numColumns: vl_size)
     -> ::std::os::raw::c_int;
}
/** ------------------------------------------------------------------
 ** @internal
 ** @brief AIB algorithm data
 **
 ** The implementation is quite straightforward, but the way feature
 ** values are handled in order to support efficient joins,
 ** deletions and re-arrangement needs to be explained. This is
 ** achieved by adding a layer of indirection:
 ** - Call each feature value (either original or obtained by a join
 **   operation) a <em>node</em>. Nodes are identified by numbers.
 ** - Call each element of the various arrays (such as VlAIB::Px)
 **    an <em>entry</em>.
 ** - Entries are dynamically associated to nodes as specified by
 **   VlAIB::nodes. For example, @c Px[i] refers to the node @c
 **   nodes[i].
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlAIB {
    /**< Entires to nodes */
    pub nodes: *mut vl_uint,
    /**< Total number of entries (= # active nodes) */
    pub nentries: vl_uint,
    /**< Minimum distance to an entry  */
    pub beta: *mut f64,
    /**< Closest entry */
    pub bidx: *mut vl_uint,
    /**< List of entries to update */
    pub which: *mut vl_uint,
    /**< Number of entries to update */
    pub nwhich: vl_uint,
    /**< Joint probability table */
    pub Pcx: *mut f64,
    /**< Marginal. */
    pub Px: *mut f64,
    /**< Marginal. */
    pub Pc: *mut f64,
    /**< Number of feature values */
    pub nvalues: vl_uint,
    /**< Number of labels */
    pub nlabels: vl_uint,
    /**< Array of parents */
    pub parents: *mut vl_uint,
    /**< Cost of each merge */
    pub costs: *mut f64,
    pub verbosity: vl_uint,
}
#[test]
fn bindgen_test_layout__VlAIB() {
    assert_eq!(::std::mem::size_of::<_VlAIB>() , 104usize , concat ! (
               "Size of: " , stringify ! ( _VlAIB ) ));
    assert_eq! (::std::mem::align_of::<_VlAIB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlAIB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . nodes as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . nentries as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( nentries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . beta as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( beta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . bidx as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( bidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . which as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . nwhich as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( nwhich ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . Pcx as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( Pcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . Px as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( Px ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . Pc as * const _ as usize } ,
                64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( Pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . nvalues as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( nvalues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . nlabels as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( nlabels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . parents as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( parents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . costs as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( costs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlAIB ) ) . verbosity as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlAIB ) , "::" ,
                stringify ! ( verbosity ) ));
}
impl Clone for _VlAIB {
    fn clone(&self) -> Self { *self }
}
pub type VlAIB = _VlAIB;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_aib_new(Pcx: *mut f64, nvalues: vl_uint, nlabels: vl_uint)
     -> *mut VlAIB;
}
extern "C" {
    pub fn vl_aib_delete(aib: *mut VlAIB);
}
extern "C" {
    /** @name Process data
 ** @{
 **/
    pub fn vl_aib_process(aib: *mut VlAIB);
}
/** @brief Numeric array */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlArray {
    pub type_: vl_type,
    pub isEnvelope: vl_bool,
    pub isSparse: vl_bool,
    pub numDimensions: vl_size,
    pub dimensions: [vl_size; 16usize],
    pub data: *mut ::std::os::raw::c_void,
    pub rowPointers: *mut ::std::os::raw::c_void,
    pub columnPointers: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__VlArray() {
    assert_eq!(::std::mem::size_of::<_VlArray>() , 176usize , concat ! (
               "Size of: " , stringify ! ( _VlArray ) ));
    assert_eq! (::std::mem::align_of::<_VlArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . isEnvelope as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( isEnvelope ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . isSparse as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( isSparse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . numDimensions as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( numDimensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . dimensions as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( dimensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . data as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . rowPointers as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( rowPointers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlArray ) ) . columnPointers as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlArray ) , "::" ,
                stringify ! ( columnPointers ) ));
}
impl Clone for _VlArray {
    fn clone(&self) -> Self { *self }
}
pub type VlArray = _VlArray;
extern "C" {
    pub fn vl_array_get_num_elements(self_: *const VlArray) -> vl_size;
}
extern "C" {
    /** @name Constructing and destroying
 ** @{ */
    pub fn vl_array_init(self_: *mut VlArray, type_: vl_type,
                         numDimension: vl_size, dimensions: *const vl_size)
     -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_init_envelope(self_: *mut VlArray,
                                  data: *mut ::std::os::raw::c_void,
                                  type_: vl_type, numDimension: vl_size,
                                  dimensions: *const vl_size) -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_init_matrix(self_: *mut VlArray, type_: vl_type,
                                numRows: vl_size, numColumns: vl_size)
     -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_init_matrix_envelope(self_: *mut VlArray,
                                         data: *mut ::std::os::raw::c_void,
                                         type_: vl_type, numRows: vl_size,
                                         numColumns: vl_size) -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_new(type_: vl_type, numDimension: vl_size,
                        dimensions: *const vl_size) -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_new_envelope(data: *mut ::std::os::raw::c_void,
                                 type_: vl_type, numDimension: vl_size,
                                 dimensions: *const vl_size) -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_new_matrix(type_: vl_type, numRows: vl_size,
                               numColumns: vl_size) -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_new_matrix_envelope(data: *mut ::std::os::raw::c_void,
                                        type_: vl_type, numRows: vl_size,
                                        numColumns: vl_size) -> *mut VlArray;
}
extern "C" {
    pub fn vl_array_dealloc(self_: *mut VlArray);
}
extern "C" {
    pub fn vl_array_delete(self_: *mut VlArray);
}
pub const VL_PROT_UNKNOWN: _bindgen_ty_5 = _bindgen_ty_5::VL_PROT_UNKNOWN;
pub const VL_PROT_NONE: _bindgen_ty_5 = _bindgen_ty_5::VL_PROT_NONE;
pub const VL_PROT_ASCII: _bindgen_ty_5 = _bindgen_ty_5::VL_PROT_ASCII;
pub const VL_PROT_BINARY: _bindgen_ty_5 = _bindgen_ty_5::VL_PROT_BINARY;
#[repr(i32)]
/** @brief File protocols */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    VL_PROT_UNKNOWN = -1,
    VL_PROT_NONE = 0,
    VL_PROT_ASCII = 1,
    VL_PROT_BINARY = 2,
}
extern "C" {
    pub fn vl_string_copy(destination: *mut ::std::os::raw::c_char,
                          destinationSize: vl_size,
                          source: *const ::std::os::raw::c_char) -> vl_size;
}
extern "C" {
    pub fn vl_string_copy_sub(destination: *mut ::std::os::raw::c_char,
                              destinationSize: vl_size,
                              beginning: *const ::std::os::raw::c_char,
                              end: *const ::std::os::raw::c_char) -> vl_size;
}
extern "C" {
    pub fn vl_string_parse_protocol(string: *const ::std::os::raw::c_char,
                                    protocol: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vl_string_protocol_name(prot: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vl_string_basename(destination: *mut ::std::os::raw::c_char,
                              destinationSize: vl_size,
                              source: *const ::std::os::raw::c_char,
                              maxNumStrippedExtension: vl_size) -> vl_size;
}
extern "C" {
    pub fn vl_string_replace_wildcard(destination:
                                          *mut ::std::os::raw::c_char,
                                      destinationSize: vl_size,
                                      src: *const ::std::os::raw::c_char,
                                      wildcardChar: ::std::os::raw::c_char,
                                      escapeChar: ::std::os::raw::c_char,
                                      replacement:
                                          *const ::std::os::raw::c_char)
     -> vl_size;
}
extern "C" {
    pub fn vl_string_find_char_rev(beginning: *const ::std::os::raw::c_char,
                                   end: *const ::std::os::raw::c_char,
                                   c: ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vl_string_length(string: *const ::std::os::raw::c_char) -> vl_size;
}
extern "C" {
    pub fn vl_string_casei_cmp(string1: *const ::std::os::raw::c_char,
                               string2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/** @brief Member of an enumeration */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlEnumerator {
    /**< enumeration member name. */
    pub name: *const ::std::os::raw::c_char,
    /**< enumeration member value. */
    pub value: vl_index,
}
#[test]
fn bindgen_test_layout__VlEnumerator() {
    assert_eq!(::std::mem::size_of::<_VlEnumerator>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _VlEnumerator ) ));
    assert_eq! (::std::mem::align_of::<_VlEnumerator>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlEnumerator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlEnumerator ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlEnumerator ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlEnumerator ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlEnumerator ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for _VlEnumerator {
    fn clone(&self) -> Self { *self }
}
pub type VlEnumerator = _VlEnumerator;
extern "C" {
    pub fn vl_enumeration_get(enumeration: *const VlEnumerator,
                              name: *const ::std::os::raw::c_char)
     -> *mut VlEnumerator;
}
extern "C" {
    pub fn vl_enumeration_get_casei(enumeration: *const VlEnumerator,
                                    name: *const ::std::os::raw::c_char)
     -> *mut VlEnumerator;
}
extern "C" {
    pub fn vl_enumeration_get_by_value(enumeration: *const VlEnumerator,
                                       value: vl_index) -> *mut VlEnumerator;
}
extern "C" {
    /** @name Image convolution
 ** @{ */
    pub fn vl_imconvcol_vf(dst: *mut f32, dst_stride: vl_size,
                           src: *const f32, src_width: vl_size,
                           src_height: vl_size, src_stride: vl_size,
                           filt: *const f32, filt_begin: vl_index,
                           filt_end: vl_index, step: ::std::os::raw::c_int,
                           flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vl_imconvcol_vd(dst: *mut f64, dst_stride: vl_size,
                           src: *const f64, src_width: vl_size,
                           src_height: vl_size, src_stride: vl_size,
                           filt: *const f64, filt_begin: vl_index,
                           filt_end: vl_index, step: ::std::os::raw::c_int,
                           flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vl_imconvcoltri_f(dest: *mut f32, destStride: vl_size,
                             image: *const f32, imageWidth: vl_size,
                             imageHeight: vl_size, imageStride: vl_size,
                             filterSize: vl_size, step: vl_size,
                             flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vl_imconvcoltri_d(dest: *mut f64, destStride: vl_size,
                             image: *const f64, imageWidth: vl_size,
                             imageHeight: vl_size, imageStride: vl_size,
                             filterSize: vl_size, step: vl_size,
                             flags: ::std::os::raw::c_uint);
}
extern "C" {
    /** @name Integral image
 ** @{ */
    pub fn vl_imintegral_f(integral: *mut f32, integralStride: vl_size,
                           image: *const f32, imageWidth: vl_size,
                           imageHeight: vl_size, imageStride: vl_size);
}
extern "C" {
    pub fn vl_imintegral_d(integral: *mut f64, integralStride: vl_size,
                           image: *const f64, imageWidth: vl_size,
                           imageHeight: vl_size, imageStride: vl_size);
}
extern "C" {
    pub fn vl_imintegral_i32(integral: *mut vl_int32, integralStride: vl_size,
                             image: *const vl_int32, imageWidth: vl_size,
                             imageHeight: vl_size, imageStride: vl_size);
}
extern "C" {
    pub fn vl_imintegral_ui32(integral: *mut vl_uint32,
                              integralStride: vl_size,
                              image: *const vl_uint32, imageWidth: vl_size,
                              imageHeight: vl_size, imageStride: vl_size);
}
extern "C" {
    /** @name Distance transform */
/** @{ */
    pub fn vl_image_distance_transform_d(image: *const f64,
                                         numColumns: vl_size,
                                         numRows: vl_size,
                                         columnStride: vl_size,
                                         rowStride: vl_size,
                                         distanceTransform: *mut f64,
                                         indexes: *mut vl_uindex, coeff: f64,
                                         offset: f64);
}
extern "C" {
    pub fn vl_image_distance_transform_f(image: *const f32,
                                         numColumns: vl_size,
                                         numRows: vl_size,
                                         columnStride: vl_size,
                                         rowStride: vl_size,
                                         distanceTransform: *mut f32,
                                         indexes: *mut vl_uindex, coeff: f32,
                                         offset: f32);
}
extern "C" {
    /** @name Image smoothing */
/** @{ */
    pub fn vl_imsmooth_f(smoothed: *mut f32, smoothedStride: vl_size,
                         image: *const f32, width: vl_size, height: vl_size,
                         stride: vl_size, sigmax: f64, sigmay: f64);
}
extern "C" {
    pub fn vl_imsmooth_d(smoothed: *mut f64, smoothedStride: vl_size,
                         image: *const f64, width: vl_size, height: vl_size,
                         stride: vl_size, sigmax: f64, sigmay: f64);
}
extern "C" {
    /** @name Image gradients */
/** @{ */
    pub fn vl_imgradient_polar_f(amplitudeGradient: *mut f32,
                                 angleGradient: *mut f32,
                                 gradWidthStride: vl_size,
                                 gradHeightStride: vl_size, image: *const f32,
                                 imageWidth: vl_size, imageHeight: vl_size,
                                 imageStride: vl_size);
}
extern "C" {
    pub fn vl_imgradient_polar_d(amplitudeGradient: *mut f64,
                                 angleGradient: *mut f64,
                                 gradWidthStride: vl_size,
                                 gradHeightStride: vl_size, image: *const f64,
                                 imageWidth: vl_size, imageHeight: vl_size,
                                 imageStride: vl_size);
}
extern "C" {
    pub fn vl_imgradient_f(xGradient: *mut f32, yGradient: *mut f32,
                           gradWidthStride: vl_size,
                           gradHeightStride: vl_size, image: *const f32,
                           imageWidth: vl_size, imageHeight: vl_size,
                           imageStride: vl_size);
}
extern "C" {
    pub fn vl_imgradient_d(xGradient: *mut f64, yGradient: *mut f64,
                           gradWidthStride: vl_size,
                           gradHeightStride: vl_size, image: *const f64,
                           imageWidth: vl_size, imageHeight: vl_size,
                           imageStride: vl_size);
}
extern "C" {
    pub fn vl_imgradient_polar_f_callback(sourceImage: *const f32,
                                          sourceImageWidth:
                                              ::std::os::raw::c_int,
                                          sourceImageHeight:
                                              ::std::os::raw::c_int,
                                          dstImage: *mut f32,
                                          dstWidth: ::std::os::raw::c_int,
                                          dstHeight: ::std::os::raw::c_int,
                                          octave: ::std::os::raw::c_int,
                                          level: ::std::os::raw::c_int,
                                          params:
                                              *mut ::std::os::raw::c_void);
}
/** @brief Geometry of a scale space
 **
 ** There are a few restrictions on the valid geometrties.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlScaleSpaceGeometry {
    /**< Image width */
    pub width: vl_size,
    /**< Image height */
    pub height: vl_size,
    /**< Index of the fisrt octave */
    pub firstOctave: vl_index,
    /**< Index of the last octave */
    pub lastOctave: vl_index,
    /**< Number of octave subdivisions */
    pub octaveResolution: vl_size,
    /**< Index of the first octave subdivision */
    pub octaveFirstSubdivision: vl_index,
    /**< Index of the last octave subdivision */
    pub octaveLastSubdivision: vl_index,
    /**< Base smoothing (smoothing of octave 0, level 0) */
    pub baseScale: f64,
    /**< Nominal smoothing of the original image */
    pub nominalScale: f64,
}
#[test]
fn bindgen_test_layout__VlScaleSpaceGeometry() {
    assert_eq!(::std::mem::size_of::<_VlScaleSpaceGeometry>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( _VlScaleSpaceGeometry )
               ));
    assert_eq! (::std::mem::align_of::<_VlScaleSpaceGeometry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlScaleSpaceGeometry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) . width as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) . height as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) . firstOctave
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( firstOctave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) . lastOctave as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( lastOctave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) .
                octaveResolution as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( octaveResolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) .
                octaveFirstSubdivision as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( octaveFirstSubdivision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) .
                octaveLastSubdivision as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( octaveLastSubdivision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) . baseScale as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( baseScale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceGeometry ) ) . nominalScale
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlScaleSpaceGeometry )
                , "::" , stringify ! ( nominalScale ) ));
}
impl Clone for _VlScaleSpaceGeometry {
    fn clone(&self) -> Self { *self }
}
pub type VlScaleSpaceGeometry = _VlScaleSpaceGeometry;
extern "C" {
    pub fn vl_scalespacegeometry_is_equal(a: VlScaleSpaceGeometry,
                                          b: VlScaleSpaceGeometry) -> vl_bool;
}
/** @brief Geometry of one octave of a scale space */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlScaleSpaceOctaveGeometry {
    /**< Width (number of pixels) */
    pub width: vl_size,
    /**< Height (number of pixels) */
    pub height: vl_size,
    /**< Sampling step (size of a pixel) */
    pub step: f64,
}
#[test]
fn bindgen_test_layout__VlScaleSpaceOctaveGeometry() {
    assert_eq!(::std::mem::size_of::<_VlScaleSpaceOctaveGeometry>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _VlScaleSpaceOctaveGeometry ) ));
    assert_eq! (::std::mem::align_of::<_VlScaleSpaceOctaveGeometry>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _VlScaleSpaceOctaveGeometry )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceOctaveGeometry ) ) . width
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlScaleSpaceOctaveGeometry ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceOctaveGeometry ) ) . height
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlScaleSpaceOctaveGeometry ) , "::" , stringify ! ( height )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlScaleSpaceOctaveGeometry ) ) . step as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlScaleSpaceOctaveGeometry ) , "::" , stringify ! ( step )
                ));
}
impl Clone for _VlScaleSpaceOctaveGeometry {
    fn clone(&self) -> Self { *self }
}
pub type VlScaleSpaceOctaveGeometry = _VlScaleSpaceOctaveGeometry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VlScaleSpace([u8; 0]);
pub type VlScaleSpace = _VlScaleSpace;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_scalespace_get_default_geometry(width: vl_size, height: vl_size)
     -> VlScaleSpaceGeometry;
}
extern "C" {
    pub fn vl_scalespace_new(width: vl_size, height: vl_size)
     -> *mut VlScaleSpace;
}
extern "C" {
    pub fn vl_scalespace_new_with_geometry(geom: VlScaleSpaceGeometry)
     -> *mut VlScaleSpace;
}
extern "C" {
    pub fn vl_scalespace_new_copy(src: *mut VlScaleSpace)
     -> *mut VlScaleSpace;
}
extern "C" {
    pub fn vl_scalespace_new_shallow_copy(src: *mut VlScaleSpace)
     -> *mut VlScaleSpace;
}
extern "C" {
    pub fn vl_scalespace_delete(self_: *mut VlScaleSpace);
}
extern "C" {
    /** @name Process data
 ** @{
 **/
    pub fn vl_scalespace_put_image(self_: *mut VlScaleSpace,
                                   image: *const f32);
}
extern "C" {
    /** @name Retrieve data and parameters
 ** @{
 **/
    pub fn vl_scalespace_get_geometry(self_: *const VlScaleSpace)
     -> VlScaleSpaceGeometry;
}
extern "C" {
    pub fn vl_scalespace_get_octave_geometry(self_: *const VlScaleSpace,
                                             o: vl_index)
     -> VlScaleSpaceOctaveGeometry;
}
extern "C" {
    pub fn vl_scalespace_get_level(self_: *mut VlScaleSpace, o: vl_index,
                                   s: vl_index) -> *mut f32;
}
extern "C" {
    pub fn vl_scalespace_get_level_const(self_: *const VlScaleSpace,
                                         o: vl_index, s: vl_index)
     -> *const f32;
}
extern "C" {
    pub fn vl_scalespace_get_level_sigma(self_: *const VlScaleSpace,
                                         o: vl_index, s: vl_index) -> f64;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(arg1: *mut ::std::os::raw::c_void, arg2: usize, arg3: usize,
                 arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(arg1: *const ::std::os::raw::c_void, arg2: usize,
                  arg3: usize, arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize,
                    arg3: ::std::os::raw::c_int, arg4: *mut FILE) -> isize;
}
extern "C" {
    pub fn getline(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize,
                   arg3: *mut FILE) -> isize;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/** @brief Types of feature frames */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlFrameType {
    VL_FRAMETYPE_DISC = 1,
    VL_FRAMETYPE_ORIENTED_DISC = 2,
    VL_FRAMETYPE_ELLIPSE = 3,
    VL_FRAMETYPE_ORIENTED_ELLIPSE = 4,
    VL_FRAMETYPE_NUM = 5,
}
pub use self::_VlFrameType as VlFrameType;
extern "C" {
    #[link_name = "vlFrameNames"]
    pub static mut vlFrameNames: [*const ::std::os::raw::c_char; 5usize];
}
extern "C" {
    #[link_name = "vlFrameTypes"]
    pub static mut vlFrameTypes: [VlEnumerator; 5usize];
}
/** @brief Disc feature frame */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlFrameDisc {
    /**< center x-coordinate */
    pub x: f32,
    /**< center y-coordinate */
    pub y: f32,
    /**< radius or scale */
    pub sigma: f32,
}
#[test]
fn bindgen_test_layout__VlFrameDisc() {
    assert_eq!(::std::mem::size_of::<_VlFrameDisc>() , 12usize , concat ! (
               "Size of: " , stringify ! ( _VlFrameDisc ) ));
    assert_eq! (::std::mem::align_of::<_VlFrameDisc>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _VlFrameDisc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameDisc ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameDisc ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameDisc ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameDisc ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameDisc ) ) . sigma as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameDisc ) , "::" ,
                stringify ! ( sigma ) ));
}
impl Clone for _VlFrameDisc {
    fn clone(&self) -> Self { *self }
}
pub type VlFrameDisc = _VlFrameDisc;
/** @brief Oriented disc feature frame
 ** An upright frame has @c angle equal to zero.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlFrameOrientedDisc {
    /**< center x-coordinate */
    pub x: f32,
    /**< center y-coordinate */
    pub y: f32,
    /**< radius or scale */
    pub sigma: f32,
    /**< rotation angle (rad) */
    pub angle: f32,
}
#[test]
fn bindgen_test_layout__VlFrameOrientedDisc() {
    assert_eq!(::std::mem::size_of::<_VlFrameOrientedDisc>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _VlFrameOrientedDisc )
               ));
    assert_eq! (::std::mem::align_of::<_VlFrameOrientedDisc>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlFrameOrientedDisc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedDisc ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedDisc )
                , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedDisc ) ) . y as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedDisc )
                , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedDisc ) ) . sigma as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedDisc )
                , "::" , stringify ! ( sigma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedDisc ) ) . angle as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedDisc )
                , "::" , stringify ! ( angle ) ));
}
impl Clone for _VlFrameOrientedDisc {
    fn clone(&self) -> Self { *self }
}
pub type VlFrameOrientedDisc = _VlFrameOrientedDisc;
/** @brief Ellipse feature frame */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlFrameEllipse {
    /**< center x-coordinate */
    pub x: f32,
    /**< center y-coordinate */
    pub y: f32,
    /**< */
    pub e11: f32,
    pub e12: f32,
    pub e22: f32,
}
#[test]
fn bindgen_test_layout__VlFrameEllipse() {
    assert_eq!(::std::mem::size_of::<_VlFrameEllipse>() , 20usize , concat ! (
               "Size of: " , stringify ! ( _VlFrameEllipse ) ));
    assert_eq! (::std::mem::align_of::<_VlFrameEllipse>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _VlFrameEllipse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameEllipse ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameEllipse ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameEllipse ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameEllipse ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameEllipse ) ) . e11 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameEllipse ) ,
                "::" , stringify ! ( e11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameEllipse ) ) . e12 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameEllipse ) ,
                "::" , stringify ! ( e12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameEllipse ) ) . e22 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameEllipse ) ,
                "::" , stringify ! ( e22 ) ));
}
impl Clone for _VlFrameEllipse {
    fn clone(&self) -> Self { *self }
}
pub type VlFrameEllipse = _VlFrameEllipse;
/** @brief Oriented ellipse feature frame
 ** The affine transformation transforms the ellipse shape into
 ** a circular region. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlFrameOrientedEllipse {
    /**< center x-coordinate */
    pub x: f32,
    /**< center y-coordinate */
    pub y: f32,
    /**< */
    pub a11: f32,
    pub a12: f32,
    pub a21: f32,
    pub a22: f32,
}
#[test]
fn bindgen_test_layout__VlFrameOrientedEllipse() {
    assert_eq!(::std::mem::size_of::<_VlFrameOrientedEllipse>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _VlFrameOrientedEllipse ) ));
    assert_eq! (::std::mem::align_of::<_VlFrameOrientedEllipse>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlFrameOrientedEllipse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedEllipse ) ) . x as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedEllipse
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedEllipse ) ) . y as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedEllipse
                ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedEllipse ) ) . a11 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedEllipse
                ) , "::" , stringify ! ( a11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedEllipse ) ) . a12 as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedEllipse
                ) , "::" , stringify ! ( a12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedEllipse ) ) . a21 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedEllipse
                ) , "::" , stringify ! ( a21 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlFrameOrientedEllipse ) ) . a22 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlFrameOrientedEllipse
                ) , "::" , stringify ! ( a22 ) ));
}
impl Clone for _VlFrameOrientedEllipse {
    fn clone(&self) -> Self { *self }
}
pub type VlFrameOrientedEllipse = _VlFrameOrientedEllipse;
/** @brief A detected feature shape and location */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlCovDetFeature {
    /**< feature frame. */
    pub frame: VlFrameOrientedEllipse,
    /**< peak score. */
    pub peakScore: f32,
    /**< edge score. */
    pub edgeScore: f32,
    /**< orientation score. */
    pub orientationScore: f32,
    /**< Laplacian scale score. */
    pub laplacianScaleScore: f32,
}
#[test]
fn bindgen_test_layout__VlCovDetFeature() {
    assert_eq!(::std::mem::size_of::<_VlCovDetFeature>() , 40usize , concat !
               ( "Size of: " , stringify ! ( _VlCovDetFeature ) ));
    assert_eq! (::std::mem::align_of::<_VlCovDetFeature>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _VlCovDetFeature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeature ) ) . frame as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlCovDetFeature ) ,
                "::" , stringify ! ( frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeature ) ) . peakScore as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlCovDetFeature ) ,
                "::" , stringify ! ( peakScore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeature ) ) . edgeScore as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlCovDetFeature ) ,
                "::" , stringify ! ( edgeScore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeature ) ) . orientationScore
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlCovDetFeature ) ,
                "::" , stringify ! ( orientationScore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeature ) ) .
                laplacianScaleScore as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _VlCovDetFeature ) ,
                "::" , stringify ! ( laplacianScaleScore ) ));
}
impl Clone for _VlCovDetFeature {
    fn clone(&self) -> Self { *self }
}
pub type VlCovDetFeature = _VlCovDetFeature;
/** @brief A detected feature orientation */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlCovDetFeatureOrientation {
    pub angle: f64,
    pub score: f64,
}
#[test]
fn bindgen_test_layout__VlCovDetFeatureOrientation() {
    assert_eq!(::std::mem::size_of::<_VlCovDetFeatureOrientation>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _VlCovDetFeatureOrientation ) ));
    assert_eq! (::std::mem::align_of::<_VlCovDetFeatureOrientation>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _VlCovDetFeatureOrientation )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeatureOrientation ) ) . angle
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlCovDetFeatureOrientation ) , "::" , stringify ! ( angle )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeatureOrientation ) ) . score
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlCovDetFeatureOrientation ) , "::" , stringify ! ( score )
                ));
}
impl Clone for _VlCovDetFeatureOrientation {
    fn clone(&self) -> Self { *self }
}
pub type VlCovDetFeatureOrientation = _VlCovDetFeatureOrientation;
/** @brief A detected feature Laplacian scale */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlCovDetFeatureLaplacianScale {
    pub scale: f64,
    pub score: f64,
}
#[test]
fn bindgen_test_layout__VlCovDetFeatureLaplacianScale() {
    assert_eq!(::std::mem::size_of::<_VlCovDetFeatureLaplacianScale>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( _VlCovDetFeatureLaplacianScale )
               ));
    assert_eq! (::std::mem::align_of::<_VlCovDetFeatureLaplacianScale>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _VlCovDetFeatureLaplacianScale
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeatureLaplacianScale ) ) .
                scale as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlCovDetFeatureLaplacianScale ) , "::" , stringify ! ( scale
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlCovDetFeatureLaplacianScale ) ) .
                score as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _VlCovDetFeatureLaplacianScale ) , "::" , stringify ! ( score
                ) ));
}
impl Clone for _VlCovDetFeatureLaplacianScale {
    fn clone(&self) -> Self { *self }
}
pub type VlCovDetFeatureLaplacianScale = _VlCovDetFeatureLaplacianScale;
#[repr(u32)]
/** @brief Covariant feature detection method */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlCovDetMethod {
    VL_COVDET_METHOD_DOG = 1,
    VL_COVDET_METHOD_HESSIAN = 2,
    VL_COVDET_METHOD_HESSIAN_LAPLACE = 3,
    VL_COVDET_METHOD_HARRIS_LAPLACE = 4,
    VL_COVDET_METHOD_MULTISCALE_HESSIAN = 5,
    VL_COVDET_METHOD_MULTISCALE_HARRIS = 6,
    VL_COVDET_METHOD_NUM = 7,
}
pub use self::_VlCovDetMethod as VlCovDetMethod;
extern "C" {
    #[link_name = "vlCovdetMethods"]
    pub static mut vlCovdetMethods: [VlEnumerator; 7usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VlCovDet([u8; 0]);
/** @brief Covariant feature detector
 ** @see @ref covdet */
pub type VlCovDet = _VlCovDet;
extern "C" {
    /** @name Create and destroy
 ** @{ */
    pub fn vl_covdet_new(method: VlCovDetMethod) -> *mut VlCovDet;
}
extern "C" {
    pub fn vl_covdet_delete(self_: *mut VlCovDet);
}
extern "C" {
    pub fn vl_covdet_reset(self_: *mut VlCovDet);
}
extern "C" {
    /** @name Process data
 ** @{ */
    pub fn vl_covdet_put_image(self_: *mut VlCovDet, image: *const f32,
                               width: vl_size, height: vl_size)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_covdet_detect(self_: *mut VlCovDet);
}
extern "C" {
    pub fn vl_covdet_append_feature(self_: *mut VlCovDet,
                                    feature: *const VlCovDetFeature)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_covdet_extract_orientations(self_: *mut VlCovDet);
}
extern "C" {
    pub fn vl_covdet_extract_laplacian_scales(self_: *mut VlCovDet);
}
extern "C" {
    pub fn vl_covdet_extract_affine_shape(self_: *mut VlCovDet);
}
extern "C" {
    pub fn vl_covdet_extract_orientations_for_frame(self_: *mut VlCovDet,
                                                    numOrientations:
                                                        *mut vl_size,
                                                    frame:
                                                        VlFrameOrientedEllipse)
     -> *mut VlCovDetFeatureOrientation;
}
extern "C" {
    pub fn vl_covdet_extract_laplacian_scales_for_frame(self_: *mut VlCovDet,
                                                        numScales:
                                                            *mut vl_size,
                                                        frame:
                                                            VlFrameOrientedEllipse)
     -> *mut VlCovDetFeatureLaplacianScale;
}
extern "C" {
    pub fn vl_covdet_extract_affine_shape_for_frame(self_: *mut VlCovDet,
                                                    adapted:
                                                        *mut VlFrameOrientedEllipse,
                                                    frame:
                                                        VlFrameOrientedEllipse)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_covdet_extract_patch_for_frame(self_: *mut VlCovDet,
                                             patch: *mut f32,
                                             resolution: vl_size, extent: f64,
                                             sigma: f64,
                                             frame: VlFrameOrientedEllipse)
     -> vl_bool;
}
extern "C" {
    pub fn vl_covdet_drop_features_outside(self_: *mut VlCovDet, margin: f64);
}
extern "C" {
    /** @name Retrieve data and parameters
 ** @{ */
    pub fn vl_covdet_get_num_features(self_: *const VlCovDet) -> vl_size;
}
extern "C" {
    pub fn vl_covdet_get_features(self_: *mut VlCovDet)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_covdet_get_first_octave(self_: *const VlCovDet) -> vl_index;
}
extern "C" {
    pub fn vl_covdet_get_octave_resolution(self_: *const VlCovDet) -> vl_size;
}
extern "C" {
    pub fn vl_covdet_get_peak_threshold(self_: *const VlCovDet) -> f64;
}
extern "C" {
    pub fn vl_covdet_get_edge_threshold(self_: *const VlCovDet) -> f64;
}
extern "C" {
    pub fn vl_covdeg_get_laplacian_peak_threshold(self_: *const VlCovDet)
     -> f64;
}
extern "C" {
    pub fn vl_covdet_get_transposed(self_: *const VlCovDet) -> vl_bool;
}
extern "C" {
    pub fn vl_covdet_get_gss(self_: *const VlCovDet) -> *mut VlScaleSpace;
}
extern "C" {
    pub fn vl_covdet_get_css(self_: *const VlCovDet) -> *mut VlScaleSpace;
}
extern "C" {
    pub fn vl_covdet_get_aa_accurate_smoothing(self_: *const VlCovDet)
     -> vl_bool;
}
extern "C" {
    pub fn vl_covdet_get_laplacian_scales_statistics(self_: *const VlCovDet,
                                                     numScales: *mut vl_size)
     -> *const vl_size;
}
extern "C" {
    pub fn vl_covdet_get_non_extrema_suppression_threshold(self_:
                                                               *const VlCovDet)
     -> f64;
}
extern "C" {
    pub fn vl_covdet_get_num_non_extrema_suppressed(self_: *const VlCovDet)
     -> vl_size;
}
extern "C" {
    /** @name Set parameters
 ** @{ */
    pub fn vl_covdet_set_first_octave(self_: *mut VlCovDet, o: vl_index);
}
extern "C" {
    pub fn vl_covdet_set_octave_resolution(self_: *mut VlCovDet, r: vl_size);
}
extern "C" {
    pub fn vl_covdet_set_peak_threshold(self_: *mut VlCovDet,
                                        peakThreshold: f64);
}
extern "C" {
    pub fn vl_covdet_set_edge_threshold(self_: *mut VlCovDet,
                                        edgeThreshold: f64);
}
extern "C" {
    pub fn vl_covdet_set_laplacian_peak_threshold(self_: *mut VlCovDet,
                                                  peakThreshold: f64);
}
extern "C" {
    pub fn vl_covdet_set_transposed(self_: *mut VlCovDet, t: vl_bool);
}
extern "C" {
    pub fn vl_covdet_set_aa_accurate_smoothing(self_: *mut VlCovDet,
                                               x: vl_bool);
}
extern "C" {
    pub fn vl_covdet_set_non_extrema_suppression_threshold(self_:
                                                               *mut VlCovDet,
                                                           x: f64);
}
/** @brief Dense SIFT keypoint */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VlDsiftKeypoint_ {
    /**< x coordinate */
    pub x: f64,
    /**< y coordinate */
    pub y: f64,
    /**< scale */
    pub s: f64,
    /**< SIFT descriptor norm */
    pub norm: f64,
}
#[test]
fn bindgen_test_layout_VlDsiftKeypoint_() {
    assert_eq!(::std::mem::size_of::<VlDsiftKeypoint_>() , 32usize , concat !
               ( "Size of: " , stringify ! ( VlDsiftKeypoint_ ) ));
    assert_eq! (::std::mem::align_of::<VlDsiftKeypoint_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VlDsiftKeypoint_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftKeypoint_ ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftKeypoint_ ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftKeypoint_ ) ) . y as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftKeypoint_ ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftKeypoint_ ) ) . s as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftKeypoint_ ) ,
                "::" , stringify ! ( s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftKeypoint_ ) ) . norm as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftKeypoint_ ) ,
                "::" , stringify ! ( norm ) ));
}
impl Clone for VlDsiftKeypoint_ {
    fn clone(&self) -> Self { *self }
}
pub type VlDsiftKeypoint = VlDsiftKeypoint_;
/** @brief Dense SIFT descriptor geometry */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VlDsiftDescriptorGeometry_ {
    /**< number of orientation bins */
    pub numBinT: ::std::os::raw::c_int,
    /**< number of bins along X */
    pub numBinX: ::std::os::raw::c_int,
    /**< number of bins along Y */
    pub numBinY: ::std::os::raw::c_int,
    /**< size of bins along X */
    pub binSizeX: ::std::os::raw::c_int,
    /**< size of bins along Y */
    pub binSizeY: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VlDsiftDescriptorGeometry_() {
    assert_eq!(::std::mem::size_of::<VlDsiftDescriptorGeometry_>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( VlDsiftDescriptorGeometry_ ) ));
    assert_eq! (::std::mem::align_of::<VlDsiftDescriptorGeometry_>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( VlDsiftDescriptorGeometry_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftDescriptorGeometry_ ) ) . numBinT
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VlDsiftDescriptorGeometry_ ) , "::" , stringify ! ( numBinT )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftDescriptorGeometry_ ) ) . numBinX
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VlDsiftDescriptorGeometry_ ) , "::" , stringify ! ( numBinX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftDescriptorGeometry_ ) ) . numBinY
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VlDsiftDescriptorGeometry_ ) , "::" , stringify ! ( numBinY )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftDescriptorGeometry_ ) ) . binSizeX
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VlDsiftDescriptorGeometry_ ) , "::" , stringify ! ( binSizeX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftDescriptorGeometry_ ) ) . binSizeY
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VlDsiftDescriptorGeometry_ ) , "::" , stringify ! ( binSizeY )
                ));
}
impl Clone for VlDsiftDescriptorGeometry_ {
    fn clone(&self) -> Self { *self }
}
pub type VlDsiftDescriptorGeometry = VlDsiftDescriptorGeometry_;
/** @brief Dense SIFT filter */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VlDsiftFilter_ {
    /**< @internal @brief image width */
    pub imWidth: ::std::os::raw::c_int,
    /**< @internal @brief image height */
    pub imHeight: ::std::os::raw::c_int,
    /**< frame sampling step X */
    pub stepX: ::std::os::raw::c_int,
    /**< frame sampling step Y */
    pub stepY: ::std::os::raw::c_int,
    /**< frame bounding box min X */
    pub boundMinX: ::std::os::raw::c_int,
    /**< frame bounding box min Y */
    pub boundMinY: ::std::os::raw::c_int,
    /**< frame bounding box max X */
    pub boundMaxX: ::std::os::raw::c_int,
    /**< frame bounding box max Y */
    pub boundMaxY: ::std::os::raw::c_int,
    /** descriptor parameters */
    pub geom: VlDsiftDescriptorGeometry,
    /**< flag: whether to approximate the Gaussian window with a flat one */
    pub useFlatWindow: ::std::os::raw::c_int,
    /**< size of the Gaussian window */
    pub windowSize: f64,
    /**< number of sampled frames */
    pub numFrames: ::std::os::raw::c_int,
    /**< size of a descriptor */
    pub descrSize: ::std::os::raw::c_int,
    /**< frame buffer */
    pub frames: *mut VlDsiftKeypoint,
    /**< descriptor buffer */
    pub descrs: *mut f32,
    /**< buffer allocated: descriptor size */
    pub numBinAlloc: ::std::os::raw::c_int,
    /**< buffer allocated: number of frames  */
    pub numFrameAlloc: ::std::os::raw::c_int,
    /**< buffer allocated: number of orientations */
    pub numGradAlloc: ::std::os::raw::c_int,
    /**< gradient buffer */
    pub grads: *mut *mut f32,
    /**< temporary buffer */
    pub convTmp1: *mut f32,
    /**< temporary buffer */
    pub convTmp2: *mut f32,
}
#[test]
fn bindgen_test_layout_VlDsiftFilter_() {
    assert_eq!(::std::mem::size_of::<VlDsiftFilter_>() , 128usize , concat ! (
               "Size of: " , stringify ! ( VlDsiftFilter_ ) ));
    assert_eq! (::std::mem::align_of::<VlDsiftFilter_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VlDsiftFilter_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . imWidth as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( imWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . imHeight as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( imHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . stepX as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( stepX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . stepY as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( stepY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . boundMinX as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( boundMinX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . boundMinY as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( boundMinY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . boundMaxX as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( boundMaxX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . boundMaxY as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( boundMaxY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . geom as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( geom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . useFlatWindow as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( useFlatWindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . windowSize as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( windowSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . numFrames as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( numFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . descrSize as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( descrSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . frames as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . descrs as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( descrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . numBinAlloc as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( numBinAlloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . numFrameAlloc as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( numFrameAlloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . numGradAlloc as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( numGradAlloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . grads as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( grads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . convTmp1 as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( convTmp1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlDsiftFilter_ ) ) . convTmp2 as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( VlDsiftFilter_ ) , "::"
                , stringify ! ( convTmp2 ) ));
}
impl Clone for VlDsiftFilter_ {
    fn clone(&self) -> Self { *self }
}
pub type VlDsiftFilter = VlDsiftFilter_;
extern "C" {
    pub fn vl_dsift_new(width: ::std::os::raw::c_int,
                        height: ::std::os::raw::c_int) -> *mut VlDsiftFilter;
}
extern "C" {
    pub fn vl_dsift_new_basic(width: ::std::os::raw::c_int,
                              height: ::std::os::raw::c_int,
                              step: ::std::os::raw::c_int,
                              binSize: ::std::os::raw::c_int)
     -> *mut VlDsiftFilter;
}
extern "C" {
    pub fn vl_dsift_delete(self_: *mut VlDsiftFilter);
}
extern "C" {
    pub fn vl_dsift_process(self_: *mut VlDsiftFilter, im: *const f32);
}
extern "C" {
    /** @} */
    pub fn _vl_dsift_update_buffers(self_: *mut VlDsiftFilter);
}
extern "C" {
    /** @} */
    pub fn vl_fisher_encode(enc: *mut ::std::os::raw::c_void,
                            dataType: vl_type,
                            means: *const ::std::os::raw::c_void,
                            dimension: vl_size, numClusters: vl_size,
                            covariances: *const ::std::os::raw::c_void,
                            priors: *const ::std::os::raw::c_void,
                            data: *const ::std::os::raw::c_void,
                            numData: vl_size, flags: ::std::os::raw::c_int)
     -> vl_size;
}
extern "C" {
    #[link_name = "opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "optreset"]
    pub static mut optreset: ::std::os::raw::c_int;
}
/** @brief ::getopt_long option */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct option {
    /**< option long name */
    pub name: *const ::std::os::raw::c_char,
    /**< flag indicating whether the option has no, required or optional argument */
    pub has_arg: ::std::os::raw::c_int,
    /**< pointer to a variable to set (if @c NULL, the value is returned instead) */
    pub flag: *mut ::std::os::raw::c_int,
    /**< value to set or to return */
    pub val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_option() {
    assert_eq!(::std::mem::size_of::<option>() , 32usize , concat ! (
               "Size of: " , stringify ! ( option ) ));
    assert_eq! (::std::mem::align_of::<option>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( option ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const option ) ) . name as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( option ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const option ) ) . has_arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( option ) , "::" ,
                stringify ! ( has_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const option ) ) . flag as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( option ) , "::" ,
                stringify ! ( flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const option ) ) . val as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( option ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for option {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getopt_long(argc: ::std::os::raw::c_int,
                       argv: *const *const ::std::os::raw::c_char,
                       optstring: *const ::std::os::raw::c_char,
                       longopts: *const option,
                       longindex: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDTreeNode {
    pub parent: vl_uindex,
    pub lowerChild: vl_index,
    pub upperChild: vl_index,
    pub splitDimension: ::std::os::raw::c_uint,
    pub splitThreshold: f64,
    pub lowerBound: f64,
    pub upperBound: f64,
}
#[test]
fn bindgen_test_layout__VlKDTreeNode() {
    assert_eq!(::std::mem::size_of::<_VlKDTreeNode>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _VlKDTreeNode ) ));
    assert_eq! (::std::mem::align_of::<_VlKDTreeNode>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlKDTreeNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . parent as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . lowerChild as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( lowerChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . upperChild as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( upperChild ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . splitDimension as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( splitDimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . splitThreshold as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( splitThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . lowerBound as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( lowerBound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeNode ) ) . upperBound as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeNode ) , "::"
                , stringify ! ( upperBound ) ));
}
impl Clone for _VlKDTreeNode {
    fn clone(&self) -> Self { *self }
}
pub type VlKDTreeNode = _VlKDTreeNode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDTreeSplitDimension {
    pub dimension: ::std::os::raw::c_uint,
    pub mean: f64,
    pub variance: f64,
}
#[test]
fn bindgen_test_layout__VlKDTreeSplitDimension() {
    assert_eq!(::std::mem::size_of::<_VlKDTreeSplitDimension>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _VlKDTreeSplitDimension ) ));
    assert_eq! (::std::mem::align_of::<_VlKDTreeSplitDimension>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlKDTreeSplitDimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeSplitDimension ) ) . dimension
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeSplitDimension
                ) , "::" , stringify ! ( dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeSplitDimension ) ) . mean as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeSplitDimension
                ) , "::" , stringify ! ( mean ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeSplitDimension ) ) . variance as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeSplitDimension
                ) , "::" , stringify ! ( variance ) ));
}
impl Clone for _VlKDTreeSplitDimension {
    fn clone(&self) -> Self { *self }
}
pub type VlKDTreeSplitDimension = _VlKDTreeSplitDimension;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDTreeDataIndexEntry {
    pub index: vl_index,
    pub value: f64,
}
#[test]
fn bindgen_test_layout__VlKDTreeDataIndexEntry() {
    assert_eq!(::std::mem::size_of::<_VlKDTreeDataIndexEntry>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _VlKDTreeDataIndexEntry ) ));
    assert_eq! (::std::mem::align_of::<_VlKDTreeDataIndexEntry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlKDTreeDataIndexEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeDataIndexEntry ) ) . index as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeDataIndexEntry
                ) , "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTreeDataIndexEntry ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTreeDataIndexEntry
                ) , "::" , stringify ! ( value ) ));
}
impl Clone for _VlKDTreeDataIndexEntry {
    fn clone(&self) -> Self { *self }
}
pub type VlKDTreeDataIndexEntry = _VlKDTreeDataIndexEntry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDForestSearchState {
    pub tree: *mut VlKDTree,
    pub nodeIndex: vl_uindex,
    pub distanceLowerBound: f64,
}
#[test]
fn bindgen_test_layout__VlKDForestSearchState() {
    assert_eq!(::std::mem::size_of::<_VlKDForestSearchState>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( _VlKDForestSearchState )
               ));
    assert_eq! (::std::mem::align_of::<_VlKDForestSearchState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlKDForestSearchState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearchState ) ) . tree as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearchState
                ) , "::" , stringify ! ( tree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearchState ) ) . nodeIndex as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearchState
                ) , "::" , stringify ! ( nodeIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearchState ) ) .
                distanceLowerBound as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearchState
                ) , "::" , stringify ! ( distanceLowerBound ) ));
}
impl Clone for _VlKDForestSearchState {
    fn clone(&self) -> Self { *self }
}
pub type VlKDForestSearchState = _VlKDForestSearchState;
#[repr(u32)]
/** @brief Thresholding method */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlKDTreeThresholdingMethod {
    VL_KDTREE_MEDIAN = 0,
    VL_KDTREE_MEAN = 1,
}
pub use self::_VlKDTreeThresholdingMethod as VlKDTreeThresholdingMethod;
/** @brief Neighbor of a query point */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDForestNeighbor {
    /**< distance to the query point */
    pub distance: f64,
    /**< index of the neighbor in the KDTree data */
    pub index: vl_uindex,
}
#[test]
fn bindgen_test_layout__VlKDForestNeighbor() {
    assert_eq!(::std::mem::size_of::<_VlKDForestNeighbor>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( _VlKDForestNeighbor ) ));
    assert_eq! (::std::mem::align_of::<_VlKDForestNeighbor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlKDForestNeighbor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestNeighbor ) ) . distance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestNeighbor ) ,
                "::" , stringify ! ( distance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestNeighbor ) ) . index as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestNeighbor ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for _VlKDForestNeighbor {
    fn clone(&self) -> Self { *self }
}
pub type VlKDForestNeighbor = _VlKDForestNeighbor;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDTree {
    pub nodes: *mut VlKDTreeNode,
    pub numUsedNodes: vl_size,
    pub numAllocatedNodes: vl_size,
    pub dataIndex: *mut VlKDTreeDataIndexEntry,
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__VlKDTree() {
    assert_eq!(::std::mem::size_of::<_VlKDTree>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _VlKDTree ) ));
    assert_eq! (::std::mem::align_of::<_VlKDTree>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlKDTree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTree ) ) . nodes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTree ) , "::" ,
                stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTree ) ) . numUsedNodes as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTree ) , "::" ,
                stringify ! ( numUsedNodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTree ) ) . numAllocatedNodes as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTree ) , "::" ,
                stringify ! ( numAllocatedNodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTree ) ) . dataIndex as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTree ) , "::" ,
                stringify ! ( dataIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDTree ) ) . depth as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDTree ) , "::" ,
                stringify ! ( depth ) ));
}
impl Clone for _VlKDTree {
    fn clone(&self) -> Self { *self }
}
pub type VlKDTree = _VlKDTree;
/** @brief ::VlKDForest searcher object */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDForestSearcher {
    pub next: *mut _VlKDForestSearcher,
    pub previous: *mut _VlKDForestSearcher,
    pub searchIdBook: *mut vl_uindex,
    pub searchHeapArray: *mut VlKDForestSearchState,
    pub forest: *mut VlKDForest,
    pub searchNumComparisons: vl_size,
    pub searchNumRecursions: vl_size,
    pub searchNumSimplifications: vl_size,
    pub searchHeapNumNodes: vl_size,
    pub searchId: vl_uindex,
}
#[test]
fn bindgen_test_layout__VlKDForestSearcher() {
    assert_eq!(::std::mem::size_of::<_VlKDForestSearcher>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( _VlKDForestSearcher ) ));
    assert_eq! (::std::mem::align_of::<_VlKDForestSearcher>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _VlKDForestSearcher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) . next as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) . previous as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( previous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) . searchIdBook as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchIdBook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) . searchHeapArray
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchHeapArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) . forest as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( forest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) .
                searchNumComparisons as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchNumComparisons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) .
                searchNumRecursions as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchNumRecursions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) .
                searchNumSimplifications as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchNumSimplifications ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) .
                searchHeapNumNodes as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchHeapNumNodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForestSearcher ) ) . searchId as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForestSearcher ) ,
                "::" , stringify ! ( searchId ) ));
}
impl Clone for _VlKDForestSearcher {
    fn clone(&self) -> Self { *self }
}
/** @brief KDForest object */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKDForest {
    pub dimension: vl_size,
    pub rand: *mut VlRand,
    pub dataType: vl_type,
    pub data: *const ::std::os::raw::c_void,
    pub numData: vl_size,
    pub distance: VlVectorComparisonType,
    pub distanceFunction: ::std::option::Option<unsafe extern "C" fn()>,
    pub trees: *mut *mut VlKDTree,
    pub numTrees: vl_size,
    pub thresholdingMethod: VlKDTreeThresholdingMethod,
    pub splitHeapArray: [VlKDTreeSplitDimension; 5usize],
    pub splitHeapNumNodes: vl_size,
    pub splitHeapSize: vl_size,
    pub maxNumNodes: vl_size,
    pub searchMaxNumComparisons: vl_size,
    pub numSearchers: vl_size,
    pub headSearcher: *mut _VlKDForestSearcher,
}
#[test]
fn bindgen_test_layout__VlKDForest() {
    assert_eq!(::std::mem::size_of::<_VlKDForest>() , 248usize , concat ! (
               "Size of: " , stringify ! ( _VlKDForest ) ));
    assert_eq! (::std::mem::align_of::<_VlKDForest>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlKDForest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . dimension as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . rand as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( rand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . dataType as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( dataType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . numData as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( numData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . distance as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( distance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . distanceFunction as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( distanceFunction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . trees as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( trees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . numTrees as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( numTrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . thresholdingMethod as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( thresholdingMethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . splitHeapArray as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( splitHeapArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . splitHeapNumNodes as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( splitHeapNumNodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . splitHeapSize as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( splitHeapSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . maxNumNodes as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( maxNumNodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . searchMaxNumComparisons
                as * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( searchMaxNumComparisons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . numSearchers as * const
                _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( numSearchers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKDForest ) ) . headSearcher as * const
                _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKDForest ) , "::" ,
                stringify ! ( headSearcher ) ));
}
impl Clone for _VlKDForest {
    fn clone(&self) -> Self { *self }
}
pub type VlKDForest = _VlKDForest;
pub type VlKDForestSearcher = _VlKDForestSearcher;
extern "C" {
    /** @name Creating, copying and disposing
 ** @{ */
    pub fn vl_kdforest_new(dataType: vl_type, dimension: vl_size,
                           numTrees: vl_size,
                           normType: VlVectorComparisonType)
     -> *mut VlKDForest;
}
extern "C" {
    pub fn vl_kdforest_new_searcher(kdforest: *mut VlKDForest)
     -> *mut VlKDForestSearcher;
}
extern "C" {
    pub fn vl_kdforest_delete(self_: *mut VlKDForest);
}
extern "C" {
    pub fn vl_kdforestsearcher_delete(searcher: *mut VlKDForestSearcher);
}
extern "C" {
    /** @name Building and querying
 ** @{ */
    pub fn vl_kdforest_build(self_: *mut VlKDForest, numData: vl_size,
                             data: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vl_kdforest_query(self_: *mut VlKDForest,
                             neighbors: *mut VlKDForestNeighbor,
                             numNeighbors: vl_size,
                             query: *const ::std::os::raw::c_void) -> vl_size;
}
extern "C" {
    pub fn vl_kdforest_query_with_array(self_: *mut VlKDForest,
                                        index: *mut vl_uint32,
                                        numNeighbors: vl_size,
                                        numQueries: vl_size,
                                        distance: *mut ::std::os::raw::c_void,
                                        queries:
                                            *const ::std::os::raw::c_void)
     -> vl_size;
}
extern "C" {
    pub fn vl_kdforestsearcher_query(self_: *mut VlKDForestSearcher,
                                     neighbors: *mut VlKDForestNeighbor,
                                     numNeighbors: vl_size,
                                     query: *const ::std::os::raw::c_void)
     -> vl_size;
}
extern "C" {
    /** @name Retrieving and setting parameters
 ** @{ */
    pub fn vl_kdforest_get_depth_of_tree(self_: *const VlKDForest,
                                         treeIndex: vl_uindex) -> vl_size;
}
extern "C" {
    pub fn vl_kdforest_get_num_nodes_of_tree(self_: *const VlKDForest,
                                             treeIndex: vl_uindex) -> vl_size;
}
extern "C" {
    pub fn vl_kdforest_get_num_trees(self_: *const VlKDForest) -> vl_size;
}
extern "C" {
    pub fn vl_kdforest_get_data_dimension(self_: *const VlKDForest)
     -> vl_size;
}
extern "C" {
    pub fn vl_kdforest_get_data_type(self_: *const VlKDForest) -> vl_type;
}
extern "C" {
    pub fn vl_kdforest_set_max_num_comparisons(self_: *mut VlKDForest,
                                               n: vl_size);
}
extern "C" {
    pub fn vl_kdforest_get_max_num_comparisons(self_: *mut VlKDForest)
     -> vl_size;
}
extern "C" {
    pub fn vl_kdforest_set_thresholding_method(self_: *mut VlKDForest,
                                               method:
                                                   VlKDTreeThresholdingMethod);
}
extern "C" {
    pub fn vl_kdforest_get_thresholding_method(self_: *const VlKDForest)
     -> VlKDTreeThresholdingMethod;
}
extern "C" {
    pub fn vl_kdforest_searcher_get_forest(self_: *const VlKDForestSearcher)
     -> *mut VlKDForest;
}
extern "C" {
    pub fn vl_kdforest_get_searcher(self_: *const VlKDForest, pos: vl_uindex)
     -> *mut VlKDForestSearcher;
}
#[repr(u32)]
/** @brief K-means algorithms */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlKMeansAlgorithm {
    VlKMeansLloyd = 0,
    VlKMeansElkan = 1,
    VlKMeansANN = 2,
}
pub use self::_VlKMeansAlgorithm as VlKMeansAlgorithm;
#[repr(u32)]
/** @brief K-means initialization algorithms */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlKMeansInitialization {
    VlKMeansRandomSelection = 0,
    VlKMeansPlusPlus = 1,
}
pub use self::_VlKMeansInitialization as VlKMeansInitialization;
/** ------------------------------------------------------------------
 ** @brief K-means quantizer
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlKMeans {
    /**< Data type. */
    pub dataType: vl_type,
    /**< Data dimensionality. */
    pub dimension: vl_size,
    /**< Number of centers. */
    pub numCenters: vl_size,
    /**< Number of trees in forest when using ANN-kmeans. */
    pub numTrees: vl_size,
    /**< Maximum number of comparisons when using ANN-kmeans. */
    pub maxNumComparisons: vl_size,
    /**< Initalization algorithm. */
    pub initialization: VlKMeansInitialization,
    /**< Clustring algorithm. */
    pub algorithm: VlKMeansAlgorithm,
    /**< Distance. */
    pub distance: VlVectorComparisonType,
    /**< Maximum number of refinement iterations. */
    pub maxNumIterations: vl_size,
    /**< Minimum energy variation. */
    pub minEnergyVariation: f64,
    /**< Number of clustering repetitions. */
    pub numRepetitions: vl_size,
    /**< Verbosity level. */
    pub verbosity: ::std::os::raw::c_int,
    /**< Centers */
    pub centers: *mut ::std::os::raw::c_void,
    /**< Centers inter-distances. */
    pub centerDistances: *mut ::std::os::raw::c_void,
    /**< Current solution energy. */
    pub energy: f64,
    pub floatVectorComparisonFn: VlFloatVectorComparisonFunction,
    pub doubleVectorComparisonFn: VlDoubleVectorComparisonFunction,
}
#[test]
fn bindgen_test_layout__VlKMeans() {
    assert_eq!(::std::mem::size_of::<_VlKMeans>() , 128usize , concat ! (
               "Size of: " , stringify ! ( _VlKMeans ) ));
    assert_eq! (::std::mem::align_of::<_VlKMeans>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlKMeans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . dataType as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( dataType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . dimension as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . numCenters as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( numCenters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . numTrees as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( numTrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . maxNumComparisons as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( maxNumComparisons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . initialization as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( initialization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . algorithm as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( algorithm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . distance as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( distance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . maxNumIterations as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( maxNumIterations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . minEnergyVariation as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( minEnergyVariation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . numRepetitions as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( numRepetitions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . verbosity as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( verbosity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . centers as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( centers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . centerDistances as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( centerDistances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . energy as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( energy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . floatVectorComparisonFn
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( floatVectorComparisonFn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlKMeans ) ) . doubleVectorComparisonFn
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlKMeans ) , "::" ,
                stringify ! ( doubleVectorComparisonFn ) ));
}
impl Clone for _VlKMeans {
    fn clone(&self) -> Self { *self }
}
pub type VlKMeans = _VlKMeans;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_kmeans_new(dataType: vl_type, distance: VlVectorComparisonType)
     -> *mut VlKMeans;
}
extern "C" {
    pub fn vl_kmeans_new_copy(kmeans: *const VlKMeans) -> *mut VlKMeans;
}
extern "C" {
    pub fn vl_kmeans_delete(self_: *mut VlKMeans);
}
extern "C" {
    /** @name Basic data processing
 ** @{
 **/
    pub fn vl_kmeans_reset(self_: *mut VlKMeans);
}
extern "C" {
    pub fn vl_kmeans_cluster(self_: *mut VlKMeans,
                             data: *const ::std::os::raw::c_void,
                             dimension: vl_size, numData: vl_size,
                             numCenters: vl_size) -> f64;
}
extern "C" {
    pub fn vl_kmeans_quantize(self_: *mut VlKMeans,
                              assignments: *mut vl_uint32,
                              distances: *mut ::std::os::raw::c_void,
                              data: *const ::std::os::raw::c_void,
                              numData: vl_size);
}
extern "C" {
    pub fn vl_kmeans_quantize_ANN(self_: *mut VlKMeans,
                                  assignments: *mut vl_uint32,
                                  distances: *mut ::std::os::raw::c_void,
                                  data: *const ::std::os::raw::c_void,
                                  numData: vl_size, iteration: vl_size);
}
extern "C" {
    /** @name Advanced data processing
 ** @{
 **/
    pub fn vl_kmeans_set_centers(self_: *mut VlKMeans,
                                 centers: *const ::std::os::raw::c_void,
                                 dimension: vl_size, numCenters: vl_size);
}
extern "C" {
    pub fn vl_kmeans_init_centers_with_rand_data(self_: *mut VlKMeans,
                                                 data:
                                                     *const ::std::os::raw::c_void,
                                                 dimensions: vl_size,
                                                 numData: vl_size,
                                                 numCenters: vl_size);
}
extern "C" {
    pub fn vl_kmeans_init_centers_plus_plus(self_: *mut VlKMeans,
                                            data:
                                                *const ::std::os::raw::c_void,
                                            dimensions: vl_size,
                                            numData: vl_size,
                                            numCenters: vl_size);
}
extern "C" {
    pub fn vl_kmeans_refine_centers(self_: *mut VlKMeans,
                                    data: *const ::std::os::raw::c_void,
                                    numData: vl_size) -> f64;
}
#[repr(u32)]
/** @brief GMM initialization algorithms */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlGMMInitialization {
    VlGMMKMeans = 0,
    VlGMMRand = 1,
    VlGMMCustom = 2,
}
pub use self::_VlGMMInitialization as VlGMMInitialization;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VlGMM([u8; 0]);
pub type VlGMM = _VlGMM;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_gmm_new(dataType: vl_type, dimension: vl_size,
                      numComponents: vl_size) -> *mut VlGMM;
}
extern "C" {
    pub fn vl_gmm_new_copy(gmm: *const VlGMM) -> *mut VlGMM;
}
extern "C" {
    pub fn vl_gmm_delete(self_: *mut VlGMM);
}
extern "C" {
    pub fn vl_gmm_reset(self_: *mut VlGMM);
}
extern "C" {
    /** @name Basic data processing
 ** @{
 **/
    pub fn vl_gmm_cluster(self_: *mut VlGMM,
                          data: *const ::std::os::raw::c_void,
                          numData: vl_size) -> f64;
}
extern "C" {
    /** @name Fine grained data processing
 ** @{ */
    pub fn vl_gmm_init_with_rand_data(self_: *mut VlGMM,
                                      data: *const ::std::os::raw::c_void,
                                      numData: vl_size);
}
extern "C" {
    pub fn vl_gmm_init_with_kmeans(self_: *mut VlGMM,
                                   data: *const ::std::os::raw::c_void,
                                   numData: vl_size,
                                   kmeansInit: *mut VlKMeans);
}
extern "C" {
    pub fn vl_gmm_em(self_: *mut VlGMM, data: *const ::std::os::raw::c_void,
                     numData: vl_size) -> f64;
}
extern "C" {
    /** @} */
    pub fn vl_gmm_set_means(self_: *mut VlGMM,
                            means: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vl_gmm_set_covariances(self_: *mut VlGMM,
                                  covariances: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vl_gmm_set_priors(self_: *mut VlGMM,
                             priors: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vl_get_gmm_data_posteriors_f(posteriors: *mut f32,
                                        numClusters: vl_size,
                                        numData: vl_size, priors: *const f32,
                                        means: *const f32, dimension: vl_size,
                                        covariances: *const f32,
                                        data: *const f32) -> f64;
}
extern "C" {
    pub fn vl_get_gmm_data_posteriors_d(posteriors: *mut f64,
                                        numClusters: vl_size,
                                        numData: vl_size, priors: *const f64,
                                        means: *const f64, dimension: vl_size,
                                        covariances: *const f64,
                                        data: *const f64) -> f64;
}
extern "C" {
    /** @name Set parameters
 ** @{
 **/
    pub fn vl_gmm_set_num_repetitions(self_: *mut VlGMM,
                                      numRepetitions: vl_size);
}
extern "C" {
    pub fn vl_gmm_set_max_num_iterations(self_: *mut VlGMM,
                                         maxNumIterations: vl_size);
}
extern "C" {
    pub fn vl_gmm_set_verbosity(self_: *mut VlGMM,
                                verbosity: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vl_gmm_set_initialization(self_: *mut VlGMM,
                                     init: VlGMMInitialization);
}
extern "C" {
    pub fn vl_gmm_set_kmeans_init_object(self_: *mut VlGMM,
                                         kmeans: *mut VlKMeans);
}
extern "C" {
    pub fn vl_gmm_set_covariance_lower_bounds(self_: *mut VlGMM,
                                              bounds: *const f64);
}
extern "C" {
    pub fn vl_gmm_set_covariance_lower_bound(self_: *mut VlGMM, bound: f64);
}
extern "C" {
    /** @name Get parameters
 ** @{
 **/
    pub fn vl_gmm_get_means(self_: *const VlGMM)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_gmm_get_covariances(self_: *const VlGMM)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_gmm_get_priors(self_: *const VlGMM)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_gmm_get_posteriors(self_: *const VlGMM)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_gmm_get_data_type(self_: *const VlGMM) -> vl_type;
}
extern "C" {
    pub fn vl_gmm_get_dimension(self_: *const VlGMM) -> vl_size;
}
extern "C" {
    pub fn vl_gmm_get_num_repetitions(self_: *const VlGMM) -> vl_size;
}
extern "C" {
    pub fn vl_gmm_get_num_data(self_: *const VlGMM) -> vl_size;
}
extern "C" {
    pub fn vl_gmm_get_num_clusters(self_: *const VlGMM) -> vl_size;
}
extern "C" {
    pub fn vl_gmm_get_loglikelihood(self_: *const VlGMM) -> f64;
}
extern "C" {
    pub fn vl_gmm_get_verbosity(self_: *const VlGMM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_gmm_get_max_num_iterations(self_: *const VlGMM) -> vl_size;
}
extern "C" {
    pub fn vl_gmm_get_initialization(self_: *const VlGMM)
     -> VlGMMInitialization;
}
extern "C" {
    pub fn vl_gmm_get_kmeans_init_object(self_: *const VlGMM)
     -> *mut VlKMeans;
}
extern "C" {
    pub fn vl_gmm_get_covariance_lower_bounds(self_: *const VlGMM)
     -> *const f64;
}
pub type vl_ikmacc_t = vl_int32;
#[repr(u32)]
/** ------------------------------------------------------------------
 ** @brief IKM algorithms
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlIKMAlgorithms { VL_IKM_LLOYD = 0, VL_IKM_ELKAN = 1, }
/** ------------------------------------------------------------------
 ** @brief IKM quantizer
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlIKMFilt {
    /**< data dimensionality */
    pub M: vl_size,
    /**< number of centers   */
    pub K: vl_size,
    /**< Lloyd: maximum number of iterations */
    pub max_niters: vl_size,
    /**< Learning method */
    pub method: ::std::os::raw::c_int,
    /**< verbosity level */
    pub verb: ::std::os::raw::c_int,
    /**< centers */
    pub centers: *mut vl_ikmacc_t,
    /**< centers inter-distances */
    pub inter_dist: *mut vl_ikmacc_t,
}
#[test]
fn bindgen_test_layout__VlIKMFilt() {
    assert_eq!(::std::mem::size_of::<_VlIKMFilt>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _VlIKMFilt ) ));
    assert_eq! (::std::mem::align_of::<_VlIKMFilt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlIKMFilt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . M as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( M ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . K as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . max_niters as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( max_niters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . method as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . verb as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( verb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . centers as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( centers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlIKMFilt ) ) . inter_dist as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlIKMFilt ) , "::" ,
                stringify ! ( inter_dist ) ));
}
impl Clone for _VlIKMFilt {
    fn clone(&self) -> Self { *self }
}
pub type VlIKMFilt = _VlIKMFilt;
extern "C" {
    /** @name Create and destroy
 ** @{ */
    pub fn vl_ikm_new(method: ::std::os::raw::c_int) -> *mut VlIKMFilt;
}
extern "C" {
    pub fn vl_ikm_delete(f: *mut VlIKMFilt);
}
extern "C" {
    /** @name Process data
 ** @{ */
    pub fn vl_ikm_init(f: *mut VlIKMFilt, centers: *const vl_ikmacc_t,
                       M: vl_size, K: vl_size);
}
extern "C" {
    pub fn vl_ikm_init_rand(f: *mut VlIKMFilt, M: vl_size, K: vl_size);
}
extern "C" {
    pub fn vl_ikm_init_rand_data(f: *mut VlIKMFilt, data: *const vl_uint8,
                                 M: vl_size, N: vl_size, K: vl_size);
}
extern "C" {
    pub fn vl_ikm_train(f: *mut VlIKMFilt, data: *const vl_uint8, N: vl_size)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_ikm_push(f: *mut VlIKMFilt, asgn: *mut vl_uint32,
                       data: *const vl_uint8, N: vl_size);
}
extern "C" {
    pub fn vl_ikm_push_one(centers: *const vl_ikmacc_t, data: *const vl_uint8,
                           M: vl_size, K: vl_size) -> vl_uint;
}
extern "C" {
    /** @name Retrieve data and parameters
 ** @{ */
    pub fn vl_ikm_get_ndims(f: *const VlIKMFilt) -> vl_size;
}
extern "C" {
    pub fn vl_ikm_get_K(f: *const VlIKMFilt) -> vl_size;
}
extern "C" {
    pub fn vl_ikm_get_verbosity(f: *const VlIKMFilt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_ikm_get_max_niters(f: *const VlIKMFilt) -> vl_size;
}
extern "C" {
    pub fn vl_ikm_get_centers(f: *const VlIKMFilt) -> *const vl_ikmacc_t;
}
extern "C" {
    /** @name Set parameters
 ** @{ */
    pub fn vl_ikm_set_verbosity(f: *mut VlIKMFilt,
                                verb: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vl_ikm_set_max_niters(f: *mut VlIKMFilt, max_niters: vl_size);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VLHIKMTree([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VLHIKMNode([u8; 0]);
/** @brief HIKM tree node
 **
 ** The number of children @a K is not bigger than the @a K parameter
 ** of the HIKM tree.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlHIKMNode {
    /**< IKM filter for this node*/
    pub filter: *mut VlIKMFilt,
    /**< Node children (if any) */
    pub children: *mut *mut _VlHIKMNode,
}
#[test]
fn bindgen_test_layout__VlHIKMNode() {
    assert_eq!(::std::mem::size_of::<_VlHIKMNode>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _VlHIKMNode ) ));
    assert_eq! (::std::mem::align_of::<_VlHIKMNode>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlHIKMNode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMNode ) ) . filter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMNode ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMNode ) ) . children as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMNode ) , "::" ,
                stringify ! ( children ) ));
}
impl Clone for _VlHIKMNode {
    fn clone(&self) -> Self { *self }
}
pub type VlHIKMNode = _VlHIKMNode;
/** @brief HIKM tree */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlHIKMTree {
    /**< IKM: data dimensionality */
    pub M: vl_size,
    /**< IKM: K */
    pub K: vl_size,
    /**< Depth of the tree */
    pub depth: vl_size,
    /**< IKM: maximum # of iterations */
    pub max_niters: vl_size,
    /**< IKM: method */
    pub method: ::std::os::raw::c_int,
    /**< Verbosity level */
    pub verb: ::std::os::raw::c_int,
    /**< Tree root node */
    pub root: *mut VlHIKMNode,
}
#[test]
fn bindgen_test_layout__VlHIKMTree() {
    assert_eq!(::std::mem::size_of::<_VlHIKMTree>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _VlHIKMTree ) ));
    assert_eq! (::std::mem::align_of::<_VlHIKMTree>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlHIKMTree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . M as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( M ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . K as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( K ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . depth as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . max_niters as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( max_niters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . method as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . verb as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( verb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlHIKMTree ) ) . root as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlHIKMTree ) , "::" ,
                stringify ! ( root ) ));
}
impl Clone for _VlHIKMTree {
    fn clone(&self) -> Self { *self }
}
pub type VlHIKMTree = _VlHIKMTree;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_hikm_new(method: ::std::os::raw::c_int) -> *mut VlHIKMTree;
}
extern "C" {
    pub fn vl_hikm_delete(f: *mut VlHIKMTree);
}
extern "C" {
    /** @name Retrieve data and parameters
 ** @{
 **/
    pub fn vl_hikm_get_ndims(f: *const VlHIKMTree) -> vl_size;
}
extern "C" {
    pub fn vl_hikm_get_K(f: *const VlHIKMTree) -> vl_size;
}
extern "C" {
    pub fn vl_hikm_get_depth(f: *const VlHIKMTree) -> vl_size;
}
extern "C" {
    pub fn vl_hikm_get_verbosity(f: *const VlHIKMTree)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_hikm_get_max_niters(f: *const VlHIKMTree) -> vl_size;
}
extern "C" {
    pub fn vl_hikm_get_root(f: *const VlHIKMTree) -> *const VlHIKMNode;
}
extern "C" {
    /** @name Set parameters
 ** @{
 **/
    pub fn vl_hikm_set_verbosity(f: *mut VlHIKMTree,
                                 verb: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vl_hikm_set_max_niters(f: *mut VlHIKMTree,
                                  max_niters: ::std::os::raw::c_int);
}
extern "C" {
    /** @name Process data
 ** @{
 **/
    pub fn vl_hikm_init(f: *mut VlHIKMTree, M: vl_size, K: vl_size,
                        depth: vl_size);
}
extern "C" {
    pub fn vl_hikm_train(f: *mut VlHIKMTree, data: *const vl_uint8,
                         N: vl_size);
}
extern "C" {
    pub fn vl_hikm_push(f: *mut VlHIKMTree, asgn: *mut vl_uint32,
                        data: *const vl_uint8, N: vl_size);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlHogVariant_ {
    VlHogVariantDalalTriggs = 0,
    VlHogVariantUoctti = 1,
}
pub use self::VlHogVariant_ as VlHogVariant;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VlHog_ {
    pub variant: VlHogVariant,
    pub dimension: vl_size,
    pub numOrientations: vl_size,
    pub transposed: vl_bool,
    pub useBilinearOrientationAssigment: vl_bool,
    pub permutation: *mut vl_index,
    pub glyphs: *mut f32,
    pub glyphSize: vl_size,
    pub orientationX: *mut f32,
    pub orientationY: *mut f32,
    pub hog: *mut f32,
    pub hogNorm: *mut f32,
    pub hogWidth: vl_size,
    pub hogHeight: vl_size,
}
#[test]
fn bindgen_test_layout_VlHog_() {
    assert_eq!(::std::mem::size_of::<VlHog_>() , 104usize , concat ! (
               "Size of: " , stringify ! ( VlHog_ ) ));
    assert_eq! (::std::mem::align_of::<VlHog_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VlHog_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . variant as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( variant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . dimension as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . numOrientations as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( numOrientations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . transposed as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( transposed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) .
                useBilinearOrientationAssigment as * const _ as usize } ,
                28usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( useBilinearOrientationAssigment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . permutation as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( permutation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . glyphs as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( glyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . glyphSize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( glyphSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . orientationX as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( orientationX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . orientationY as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( orientationY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . hog as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( hog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . hogNorm as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( hogNorm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . hogWidth as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( hogWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlHog_ ) ) . hogHeight as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( VlHog_ ) , "::" ,
                stringify ! ( hogHeight ) ));
}
impl Clone for VlHog_ {
    fn clone(&self) -> Self { *self }
}
pub type VlHog = VlHog_;
extern "C" {
    pub fn vl_hog_new(variant: VlHogVariant, numOrientations: vl_size,
                      transposed: vl_bool) -> *mut VlHog;
}
extern "C" {
    pub fn vl_hog_delete(self_: *mut VlHog);
}
extern "C" {
    pub fn vl_hog_process(self_: *mut VlHog, features: *mut f32,
                          image: *const f32, width: vl_size, height: vl_size,
                          numChannels: vl_size, cellSize: vl_size);
}
extern "C" {
    pub fn vl_hog_put_image(self_: *mut VlHog, image: *const f32,
                            width: vl_size, height: vl_size,
                            numChannels: vl_size, cellSize: vl_size);
}
extern "C" {
    pub fn vl_hog_put_polar_field(self_: *mut VlHog, modulus: *const f32,
                                  angle: *const f32, directed: vl_bool,
                                  width: vl_size, height: vl_size,
                                  cellSize: vl_size);
}
extern "C" {
    pub fn vl_hog_extract(self_: *mut VlHog, features: *mut f32);
}
extern "C" {
    pub fn vl_hog_get_height(self_: *mut VlHog) -> vl_size;
}
extern "C" {
    pub fn vl_hog_get_width(self_: *mut VlHog) -> vl_size;
}
extern "C" {
    pub fn vl_hog_render(self_: *const VlHog, image: *mut f32,
                         features: *const f32, width: vl_size,
                         height: vl_size);
}
extern "C" {
    pub fn vl_hog_get_dimension(self_: *const VlHog) -> vl_size;
}
extern "C" {
    pub fn vl_hog_get_permutation(self_: *const VlHog) -> *const vl_index;
}
extern "C" {
    pub fn vl_hog_get_glyph_size(self_: *const VlHog) -> vl_size;
}
extern "C" {
    pub fn vl_hog_get_use_bilinear_orientation_assignments(self_:
                                                               *const VlHog)
     -> vl_bool;
}
extern "C" {
    pub fn vl_hog_set_use_bilinear_orientation_assignments(self_: *mut VlHog,
                                                           x: vl_bool);
}
#[repr(u32)]
/** @brief Type of kernel */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlHomogeneousKernelType {
    VlHomogeneousKernelIntersection = 0,
    VlHomogeneousKernelChi2 = 1,
    VlHomogeneousKernelJS = 2,
}
#[repr(u32)]
/** @brief Type of spectral windowing function  */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlHomogeneousKernelMapWindowType {
    VlHomogeneousKernelMapWindowUniform = 0,
    VlHomogeneousKernelMapWindowRectangular = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VlHomogeneousKernelMap([u8; 0]);
pub type VlHomogeneousKernelMap = _VlHomogeneousKernelMap;
extern "C" {
    /** @name Create and destroy
 ** @{ */
    pub fn vl_homogeneouskernelmap_new(kernelType: VlHomogeneousKernelType,
                                       gamma: f64, order: vl_size,
                                       period: f64,
                                       windowType:
                                           VlHomogeneousKernelMapWindowType)
     -> *mut VlHomogeneousKernelMap;
}
extern "C" {
    pub fn vl_homogeneouskernelmap_delete(self_: *mut VlHomogeneousKernelMap);
}
extern "C" {
    /** @name Process data
 ** @{ */
    pub fn vl_homogeneouskernelmap_evaluate_d(self_:
                                                  *const VlHomogeneousKernelMap,
                                              destination: *mut f64,
                                              stride: vl_size, x: f64);
}
extern "C" {
    pub fn vl_homogeneouskernelmap_evaluate_f(self_:
                                                  *const VlHomogeneousKernelMap,
                                              destination: *mut f32,
                                              stride: vl_size, x: f64);
}
extern "C" {
    /** @name Retrieve data and parameters
 ** @{ */
    pub fn vl_homogeneouskernelmap_get_order(self_:
                                                 *const VlHomogeneousKernelMap)
     -> vl_size;
}
extern "C" {
    pub fn vl_homogeneouskernelmap_get_dimension(self_:
                                                     *const VlHomogeneousKernelMap)
     -> vl_size;
}
extern "C" {
    pub fn vl_homogeneouskernelmap_get_kernel_type(self_:
                                                       *const VlHomogeneousKernelMap)
     -> VlHomogeneousKernelType;
}
extern "C" {
    pub fn vl_homogeneouskernelmap_get_window_type(self_:
                                                       *const VlHomogeneousKernelMap)
     -> VlHomogeneousKernelMapWindowType;
}
extern "C" {
    pub fn _vl_imconvcol_vf_sse2(dst: *mut f32, dst_stride: vl_size,
                                 src: *const f32, src_width: vl_size,
                                 src_height: vl_size, src_stride: vl_size,
                                 filt: *const f32, filt_begin: vl_index,
                                 filt_end: vl_index,
                                 step: ::std::os::raw::c_int,
                                 flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _vl_imconvcol_vd_sse2(dst: *mut f64, dst_stride: vl_size,
                                 src: *const f64, src_width: vl_size,
                                 src_height: vl_size, src_stride: vl_size,
                                 filt: *const f64, filt_begin: vl_index,
                                 filt_end: vl_index,
                                 step: ::std::os::raw::c_int,
                                 flags: ::std::os::raw::c_uint);
}
#[repr(u32)]
/** @brief Type of quantization for the LBP descriptors
 ** @see @ref lbp-quantization
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _VlLbpMappingType { VlLbpUniform = 0, }
pub use self::_VlLbpMappingType as VlLbpMappingType;
/** @brief Local Binary Pattern extractor */
#[repr(C)]
pub struct VlLbp_ {
    pub dimension: vl_size,
    pub mapping: [vl_uint8; 256usize],
    pub transposed: vl_bool,
}
#[test]
fn bindgen_test_layout_VlLbp_() {
    assert_eq!(::std::mem::size_of::<VlLbp_>() , 272usize , concat ! (
               "Size of: " , stringify ! ( VlLbp_ ) ));
    assert_eq! (::std::mem::align_of::<VlLbp_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VlLbp_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlLbp_ ) ) . dimension as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VlLbp_ ) , "::" ,
                stringify ! ( dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlLbp_ ) ) . mapping as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VlLbp_ ) , "::" ,
                stringify ! ( mapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlLbp_ ) ) . transposed as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( VlLbp_ ) , "::" ,
                stringify ! ( transposed ) ));
}
pub type VlLbp = VlLbp_;
extern "C" {
    pub fn vl_lbp_new(type_: VlLbpMappingType, transposed: vl_bool)
     -> *mut VlLbp;
}
extern "C" {
    pub fn vl_lbp_delete(self_: *mut VlLbp);
}
extern "C" {
    pub fn vl_lbp_process(self_: *mut VlLbp, features: *mut f32,
                          image: *mut f32, width: vl_size, height: vl_size,
                          cellSize: vl_size);
}
extern "C" {
    pub fn vl_lbp_get_dimension(self_: *mut VlLbp) -> vl_size;
}
/** @brief LIOP descriptor extractor object */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlLiopDesc {
    /**< Number of neighbours. */
    pub numNeighbours: vl_int,
    /**< Number of bins. */
    pub numSpatialBins: vl_int,
    /**< Weight threshold. */
    pub intensityThreshold: f32,
    /**< LIOP descriptor size. */
    pub dimension: vl_size,
    pub patchSideLength: vl_size,
    pub patchSize: vl_size,
    pub patchPixels: *mut vl_uindex,
    pub patchIntensities: *mut f32,
    pub patchPermutation: *mut vl_uindex,
    /**< Point to neighbour radius (distance). */
    pub neighRadius: f32,
    pub neighIntensities: *mut f32,
    pub neighPermutation: *mut vl_uindex,
    pub neighSamplesX: *mut f64,
    pub neighSamplesY: *mut f64,
}
#[test]
fn bindgen_test_layout__VlLiopDesc() {
    assert_eq!(::std::mem::size_of::<_VlLiopDesc>() , 104usize , concat ! (
               "Size of: " , stringify ! ( _VlLiopDesc ) ));
    assert_eq! (::std::mem::align_of::<_VlLiopDesc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlLiopDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . numNeighbours as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( numNeighbours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . numSpatialBins as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( numSpatialBins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . intensityThreshold as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( intensityThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . dimension as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . patchSideLength as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( patchSideLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . patchSize as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( patchSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . patchPixels as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( patchPixels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . patchIntensities as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( patchIntensities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . patchPermutation as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( patchPermutation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . neighRadius as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( neighRadius ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . neighIntensities as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( neighIntensities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . neighPermutation as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( neighPermutation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . neighSamplesX as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( neighSamplesX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlLiopDesc ) ) . neighSamplesY as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlLiopDesc ) , "::" ,
                stringify ! ( neighSamplesY ) ));
}
impl Clone for _VlLiopDesc {
    fn clone(&self) -> Self { *self }
}
pub type VlLiopDesc = _VlLiopDesc;
extern "C" {
    /** @name Construct and destroy
 ** @{ */
    pub fn vl_liopdesc_new(numNeighbours: vl_int, numSpatialBins: vl_int,
                           radius: f32, sideLength: vl_size)
     -> *mut VlLiopDesc;
}
extern "C" {
    pub fn vl_liopdesc_new_basic(sideLength: vl_size) -> *mut VlLiopDesc;
}
extern "C" {
    pub fn vl_liopdesc_delete(self_: *mut VlLiopDesc);
}
extern "C" {
    /**  @name Get data and parameters
 **  @{ */
    pub fn vl_liopdesc_get_dimension(self_: *const VlLiopDesc) -> vl_size;
}
extern "C" {
    pub fn vl_liopdesc_get_num_neighbours(self_: *const VlLiopDesc)
     -> vl_size;
}
extern "C" {
    pub fn vl_liopdesc_get_intensity_threshold(self_: *const VlLiopDesc)
     -> f32;
}
extern "C" {
    pub fn vl_liopdesc_get_num_spatial_bins(self_: *const VlLiopDesc)
     -> vl_size;
}
extern "C" {
    pub fn vl_liopdesc_get_neighbourhood_radius(self_: *const VlLiopDesc)
     -> f64;
}
extern "C" {
    pub fn vl_liopdesc_set_intensity_threshold(self_: *mut VlLiopDesc,
                                               x: f32);
}
extern "C" {
    /**  @name Compute LIOP descriptor
 **  @{ */
    pub fn vl_liopdesc_process(liop: *mut VlLiopDesc, desc: *mut f32,
                               patch: *const f32);
}
extern "C" {
    pub fn _vl_distance_mahalanobis_sq_avx_d(dimension: vl_size,
                                             X: *const f64, MU: *const f64,
                                             S: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_distance_l2_avx_d(dimension: vl_size, X: *const f64,
                                 Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_weighted_sigma_avx_d(dimension: vl_size, S: *mut f64,
                                    X: *const f64, Y: *const f64, W: f64);
}
extern "C" {
    pub fn _vl_weighted_mean_avx_d(dimension: vl_size, MU: *mut f64,
                                   X: *const f64, W: f64);
}
extern "C" {
    pub fn _vl_distance_mahalanobis_sq_avx_f(dimension: vl_size,
                                             X: *const f32, MU: *const f32,
                                             S: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_distance_l2_avx_f(dimension: vl_size, X: *const f32,
                                 Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_weighted_sigma_avx_f(dimension: vl_size, S: *mut f32,
                                    X: *const f32, Y: *const f32, W: f32);
}
extern "C" {
    pub fn _vl_weighted_mean_avx_f(dimension: vl_size, MU: *mut f32,
                                   X: *const f32, W: f32);
}
extern "C" {
    pub fn _vl_dot_sse2_d(dimension: vl_size, X: *const f64, Y: *const f64)
     -> f64;
}
extern "C" {
    pub fn _vl_distance_l2_sse2_d(dimension: vl_size, X: *const f64,
                                  Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_distance_l1_sse2_d(dimension: vl_size, X: *const f64,
                                  Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_distance_chi2_sse2_d(dimension: vl_size, X: *const f64,
                                    Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_kernel_l2_sse2_d(dimension: vl_size, X: *const f64,
                                Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_kernel_l1_sse2_d(dimension: vl_size, X: *const f64,
                                Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_kernel_chi2_sse2_d(dimension: vl_size, X: *const f64,
                                  Y: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_distance_mahalanobis_sq_sse2_d(dimension: vl_size,
                                              X: *const f64, MU: *const f64,
                                              S: *const f64) -> f64;
}
extern "C" {
    pub fn _vl_weighted_sigma_sse2_d(dimension: vl_size, S: *mut f64,
                                     X: *const f64, Y: *const f64, W: f64);
}
extern "C" {
    pub fn _vl_weighted_mean_sse2_d(dimension: vl_size, MU: *mut f64,
                                    X: *const f64, W: f64);
}
extern "C" {
    pub fn _vl_dot_sse2_f(dimension: vl_size, X: *const f32, Y: *const f32)
     -> f32;
}
extern "C" {
    pub fn _vl_distance_l2_sse2_f(dimension: vl_size, X: *const f32,
                                  Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_distance_l1_sse2_f(dimension: vl_size, X: *const f32,
                                  Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_distance_chi2_sse2_f(dimension: vl_size, X: *const f32,
                                    Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_kernel_l2_sse2_f(dimension: vl_size, X: *const f32,
                                Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_kernel_l1_sse2_f(dimension: vl_size, X: *const f32,
                                Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_kernel_chi2_sse2_f(dimension: vl_size, X: *const f32,
                                  Y: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_distance_mahalanobis_sq_sse2_f(dimension: vl_size,
                                              X: *const f32, MU: *const f32,
                                              S: *const f32) -> f32;
}
extern "C" {
    pub fn _vl_weighted_sigma_sse2_f(dimension: vl_size, S: *mut f32,
                                     X: *const f32, Y: *const f32, W: f32);
}
extern "C" {
    pub fn _vl_weighted_mean_sse2_f(dimension: vl_size, MU: *mut f32,
                                    X: *const f32, W: f32);
}
/** @brief MSER image data type
 **
 ** This is the data type of the image pixels. It has to be an
 ** integer.
 **/
pub type vl_mser_pix = vl_uint8;
/** @internal
 ** @brief MSER filter
 ** @see @ref mser
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlMserFilt {
    /**< number of dimensions                    */
    pub ndims: ::std::os::raw::c_int,
    /**< dimensions                              */
    pub dims: *mut ::std::os::raw::c_int,
    /**< number of image elements (pixels)       */
    pub nel: ::std::os::raw::c_int,
    /**< N-dimensional subscript                 */
    pub subs: *mut ::std::os::raw::c_int,
    /**< another subscript                       */
    pub dsubs: *mut ::std::os::raw::c_int,
    /**< strides to move in image data           */
    pub strides: *mut ::std::os::raw::c_int,
    /**< pixel ordering                          */
    pub perm: *mut vl_uint,
    /**< sequence of join ops                    */
    pub joins: *mut vl_uint,
    /**< number of join ops                      */
    pub njoins: ::std::os::raw::c_int,
    /**< basic regions                           */
    pub r: *mut VlMserReg,
    /**< extremal tree                           */
    pub er: *mut VlMserExtrReg,
    /**< maximally stable extremal regions       */
    pub mer: *mut vl_uint,
    /**< number of extremal regions              */
    pub ner: ::std::os::raw::c_int,
    /**< number of maximally stable extr. reg.   */
    pub nmer: ::std::os::raw::c_int,
    /**< size of er buffer                       */
    pub rer: ::std::os::raw::c_int,
    /**< size of mer buffer                      */
    pub rmer: ::std::os::raw::c_int,
    /**< moment accumulator.                    */
    pub acc: *mut f32,
    /**< ellipsoids list.                       */
    pub ell: *mut f32,
    /**< size of ell buffer                     */
    pub rell: ::std::os::raw::c_int,
    /**< number of ellipsoids extracted         */
    pub nell: ::std::os::raw::c_int,
    /**< number of dof of ellipsoids.           */
    pub dof: ::std::os::raw::c_int,
    /**< be verbose                             */
    pub verbose: vl_bool,
    /**< delta filter parameter                 */
    pub delta: ::std::os::raw::c_int,
    /**< badness test parameter                 */
    pub max_area: f64,
    /**< badness test parameter                 */
    pub min_area: f64,
    /**< badness test parameter                 */
    pub max_variation: f64,
    /**< minimum diversity                      */
    pub min_diversity: f64,
    pub stats: VlMserStats,
}
#[test]
fn bindgen_test_layout__VlMserFilt() {
    assert_eq!(::std::mem::size_of::<_VlMserFilt>() , 208usize , concat ! (
               "Size of: " , stringify ! ( _VlMserFilt ) ));
    assert_eq! (::std::mem::align_of::<_VlMserFilt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlMserFilt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . ndims as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( ndims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . dims as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( dims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . nel as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( nel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . subs as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( subs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . dsubs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( dsubs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . strides as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( strides ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . perm as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( perm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . joins as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( joins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . njoins as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( njoins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . r as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . er as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( er ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . mer as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( mer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . ner as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( ner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . nmer as * const _ as
                usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( nmer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . rer as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( rer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . rmer as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( rmer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . acc as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( acc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . ell as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( ell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . rell as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( rell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . nell as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( nell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . dof as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( dof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . verbose as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . delta as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . max_area as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( max_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . min_area as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( min_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . max_variation as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( max_variation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . min_diversity as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( min_diversity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserFilt ) ) . stats as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserFilt ) , "::" ,
                stringify ! ( stats ) ));
}
impl Clone for _VlMserFilt {
    fn clone(&self) -> Self { *self }
}
/** @brief MSER Filter
 **
 ** The MSER filter computes the Maximally Stable Extremal Regions of
 ** an image.
 **
 ** @sa @ref mser
 **/
pub type VlMserFilt = _VlMserFilt;
/** @brief MSER filter statistics definition */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlMserStats {
    /**< number of extremal regions                                */
    pub num_extremal: ::std::os::raw::c_int,
    /**< number of unstable extremal regions                       */
    pub num_unstable: ::std::os::raw::c_int,
    /**< number of regions that failed the absolute stability test */
    pub num_abs_unstable: ::std::os::raw::c_int,
    /**< number of regions that failed the maximum size test       */
    pub num_too_big: ::std::os::raw::c_int,
    /**< number of regions that failed the minimum size test       */
    pub num_too_small: ::std::os::raw::c_int,
    /**< number of regions that failed the duplicate test          */
    pub num_duplicates: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VlMserStats() {
    assert_eq!(::std::mem::size_of::<_VlMserStats>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _VlMserStats ) ));
    assert_eq! (::std::mem::align_of::<_VlMserStats>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _VlMserStats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserStats ) ) . num_extremal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserStats ) , "::" ,
                stringify ! ( num_extremal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserStats ) ) . num_unstable as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserStats ) , "::" ,
                stringify ! ( num_unstable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserStats ) ) . num_abs_unstable as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserStats ) , "::" ,
                stringify ! ( num_abs_unstable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserStats ) ) . num_too_big as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserStats ) , "::" ,
                stringify ! ( num_too_big ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserStats ) ) . num_too_small as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserStats ) , "::" ,
                stringify ! ( num_too_small ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserStats ) ) . num_duplicates as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserStats ) , "::" ,
                stringify ! ( num_duplicates ) ));
}
impl Clone for _VlMserStats {
    fn clone(&self) -> Self { *self }
}
/** @brief MSER filter statistics */
pub type VlMserStats = _VlMserStats;
extern "C" {
    /** @name Construction and Destruction
 ** @{
 **/
    pub fn vl_mser_new(ndims: ::std::os::raw::c_int,
                       dims: *const ::std::os::raw::c_int) -> *mut VlMserFilt;
}
extern "C" {
    pub fn vl_mser_delete(f: *mut VlMserFilt);
}
extern "C" {
    /** @name Processing
 ** @{
 **/
    pub fn vl_mser_process(f: *mut VlMserFilt, im: *const vl_mser_pix);
}
extern "C" {
    pub fn vl_mser_ell_fit(f: *mut VlMserFilt);
}
/** @internal
 ** @brief MSER accumulator data type
 **
 ** This is a large integer type. It should be large enough to contain
 ** a number equal to the area (volume) of the image by the image
 ** width by the image height (for instance, if the image is a square
 ** of side 256, the maximum value is 256 x 256 x 256).
 **/
pub type vl_mser_acc = f32;
/** @internal
 ** @brief MSER: basic region (declaration)
 **
 ** Extremal regions and maximally stable extremal regions are
 ** instances of image regions.
 **
 ** There is an image region for each pixel of the image. Each region
 ** is represented by an instance of this structure.  Regions are
 ** stored into an array in pixel order.
 **
 ** Regions are arranged into a forest. VlMserReg::parent points to
 ** the parent node, or to the node itself if the node is a root.
 ** VlMserReg::parent is the index of the node in the node array
 ** (which therefore is also the index of the corresponding
 ** pixel). VlMserReg::height is the distance of the fartest leaf. If
 ** the node itself is a leaf, then VlMserReg::height is zero.
 **
 ** VlMserReg::area is the area of the image region corresponding to
 ** this node.
 **
 ** VlMserReg::region is the extremal region identifier. Not all
 ** regions are extremal regions however; if the region is NOT
 ** extremal, this field is set to ....
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlMserReg {
    /**< points to the parent region.            */
    pub parent: vl_uint,
    /**< points to a region closer to a root.    */
    pub shortcut: vl_uint,
    /**< region height in the forest.            */
    pub height: vl_uint,
    /**< area of the region.                     */
    pub area: vl_uint,
}
#[test]
fn bindgen_test_layout__VlMserReg() {
    assert_eq!(::std::mem::size_of::<_VlMserReg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _VlMserReg ) ));
    assert_eq! (::std::mem::align_of::<_VlMserReg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _VlMserReg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserReg ) ) . parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserReg ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserReg ) ) . shortcut as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserReg ) , "::" ,
                stringify ! ( shortcut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserReg ) ) . height as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserReg ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserReg ) ) . area as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserReg ) , "::" ,
                stringify ! ( area ) ));
}
impl Clone for _VlMserReg {
    fn clone(&self) -> Self { *self }
}
/** @internal @brief MSER: basic region */
pub type VlMserReg = _VlMserReg;
/** @internal
 ** @brief MSER: extremal region (declaration)
 **
 ** Extremal regions (ER) are extracted from the region forest. Each
 ** region is represented by an instance of this structure. The
 ** structures are stored into an array, in arbitrary order.
 **
 ** ER are arranged into a tree. @a parent points to the parent ER, or
 ** to itself if the ER is the root.
 **
 ** An instance of the structure represents the extremal region of the
 ** level set of intensity VlMserExtrReg::value and containing the
 ** pixel VlMserExtReg::index.
 **
 ** VlMserExtrReg::area is the area of the extremal region and
 ** VlMserExtrReg::area_top is the area of the extremal region
 ** containing this region in the level set of intensity
 ** VlMserExtrReg::area + @c delta.
 **
 ** VlMserExtrReg::variation is the relative area variation @c
 ** (area_top-area)/area.
 **
 ** VlMserExtrReg::max_stable is a flag signaling whether this extremal
 ** region is also maximally stable.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlMserExtrReg {
    /**< index of the parent region                   */
    pub parent: ::std::os::raw::c_int,
    /**< index of pivot pixel                         */
    pub index: ::std::os::raw::c_int,
    /**< value of pivot pixel                         */
    pub value: vl_mser_pix,
    /**< shortcut used when building a tree           */
    pub shortcut: vl_uint,
    /**< area of the region                           */
    pub area: vl_uint,
    /**< rel. area variation                          */
    pub variation: f32,
    /**< max stable number (=0 if not maxstable)      */
    pub max_stable: vl_uint,
}
#[test]
fn bindgen_test_layout__VlMserExtrReg() {
    assert_eq!(::std::mem::size_of::<_VlMserExtrReg>() , 28usize , concat ! (
               "Size of: " , stringify ! ( _VlMserExtrReg ) ));
    assert_eq! (::std::mem::align_of::<_VlMserExtrReg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _VlMserExtrReg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . parent as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . index as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . shortcut as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( shortcut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . area as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . variation as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( variation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlMserExtrReg ) ) . max_stable as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlMserExtrReg ) , "::"
                , stringify ! ( max_stable ) ));
}
impl Clone for _VlMserExtrReg {
    fn clone(&self) -> Self { *self }
}
/** @internal
 ** @brief MSER: extremal region */
pub type VlMserExtrReg = _VlMserExtrReg;
/** @brief PGM image meta data
 **
 ** A PGM image is a 2-D array of pixels of width #width and height
 ** #height. Each pixel is an integer one or two bytes wide, depending
 ** whether #max_value is smaller than 256.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlPgmImage {
    /**< image width.                     */
    pub width: vl_size,
    /**< image height.                    */
    pub height: vl_size,
    /**< pixel maximum value (<= 2^16-1). */
    pub max_value: vl_size,
    /**< is RAW format?                   */
    pub is_raw: vl_bool,
}
#[test]
fn bindgen_test_layout__VlPgmImage() {
    assert_eq!(::std::mem::size_of::<_VlPgmImage>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _VlPgmImage ) ));
    assert_eq! (::std::mem::align_of::<_VlPgmImage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlPgmImage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlPgmImage ) ) . width as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlPgmImage ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlPgmImage ) ) . height as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlPgmImage ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlPgmImage ) ) . max_value as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlPgmImage ) , "::" ,
                stringify ! ( max_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlPgmImage ) ) . is_raw as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlPgmImage ) , "::" ,
                stringify ! ( is_raw ) ));
}
impl Clone for _VlPgmImage {
    fn clone(&self) -> Self { *self }
}
pub type VlPgmImage = _VlPgmImage;
extern "C" {
    /** @name Core operations
 ** @{ */
    pub fn vl_pgm_extract_head(f: *mut FILE, im: *mut VlPgmImage)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_pgm_extract_data(f: *mut FILE, im: *const VlPgmImage,
                               data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_pgm_insert(f: *mut FILE, im: *const VlPgmImage,
                         data: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_pgm_get_npixels(im: *const VlPgmImage) -> vl_size;
}
extern "C" {
    pub fn vl_pgm_get_bpp(im: *const VlPgmImage) -> vl_size;
}
extern "C" {
    /** @name Helper functions
 ** @{ */
    pub fn vl_pgm_write(name: *const ::std::os::raw::c_char,
                        data: *const vl_uint8, width: ::std::os::raw::c_int,
                        height: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_pgm_write_f(name: *const ::std::os::raw::c_char,
                          data: *const f32, width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_pgm_read_new(name: *const ::std::os::raw::c_char,
                           im: *mut VlPgmImage, data: *mut *mut vl_uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_pgm_read_new_f(name: *const ::std::os::raw::c_char,
                             im: *mut VlPgmImage, data: *mut *mut f32)
     -> ::std::os::raw::c_int;
}
/** @brief quick shift datatype */
pub type vl_qs_type = f64;
/** ------------------------------------------------------------------
 ** @brief quick shift results
 **
 ** This implements quick shift mode seeking.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlQS {
    /**< height x width x channels feature image */
    pub image: *mut vl_qs_type,
    /**< height of the image */
    pub height: ::std::os::raw::c_int,
    /**< width of the image */
    pub width: ::std::os::raw::c_int,
    /**< number of channels in the image */
    pub channels: ::std::os::raw::c_int,
    pub medoid: vl_bool,
    pub sigma: vl_qs_type,
    pub tau: vl_qs_type,
    pub parents: *mut ::std::os::raw::c_int,
    pub dists: *mut vl_qs_type,
    pub density: *mut vl_qs_type,
}
#[test]
fn bindgen_test_layout__VlQS() {
    assert_eq!(::std::mem::size_of::<_VlQS>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _VlQS ) ));
    assert_eq! (::std::mem::align_of::<_VlQS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlQS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . image as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . height as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . width as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . channels as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . medoid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( medoid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . sigma as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( sigma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . tau as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( tau ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . parents as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( parents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . dists as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( dists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlQS ) ) . density as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlQS ) , "::" ,
                stringify ! ( density ) ));
}
impl Clone for _VlQS {
    fn clone(&self) -> Self { *self }
}
pub type VlQS = _VlQS;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_quickshift_new(im: *const vl_qs_type,
                             height: ::std::os::raw::c_int,
                             width: ::std::os::raw::c_int,
                             channels: ::std::os::raw::c_int) -> *mut VlQS;
}
extern "C" {
    pub fn vl_quickshift_delete(q: *mut VlQS);
}
extern "C" {
    /** @name Process data
 ** @{
 **/
    pub fn vl_quickshift_process(q: *mut VlQS);
}
extern "C" {
    pub fn vl_rodrigues(R_pt: *mut f64, dR_pt: *mut f64, om_pt: *const f64);
}
extern "C" {
    pub fn vl_irodrigues(om_pt: *mut f64, dom_pt: *mut f64, R_pt: *const f64);
}
/** @brief SIFT filter pixel type */
pub type vl_sift_pix = f32;
/** ------------------------------------------------------------------
 ** @brief SIFT filter keypoint
 **
 ** This structure represent a keypoint as extracted by the SIFT
 ** filter ::VlSiftFilt.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlSiftKeypoint {
    /**< o coordinate (octave). */
    pub o: ::std::os::raw::c_int,
    /**< Integer unnormalized x coordinate. */
    pub ix: ::std::os::raw::c_int,
    /**< Integer unnormalized y coordinate. */
    pub iy: ::std::os::raw::c_int,
    /**< Integer s coordinate. */
    pub is: ::std::os::raw::c_int,
    /**< x coordinate. */
    pub x: f32,
    /**< y coordinate. */
    pub y: f32,
    /**< s coordinate. */
    pub s: f32,
    /**< scale. */
    pub sigma: f32,
}
#[test]
fn bindgen_test_layout__VlSiftKeypoint() {
    assert_eq!(::std::mem::size_of::<_VlSiftKeypoint>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _VlSiftKeypoint ) ));
    assert_eq! (::std::mem::align_of::<_VlSiftKeypoint>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _VlSiftKeypoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . o as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( o ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . ix as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( ix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . iy as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( iy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . is as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( is ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . x as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . y as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . s as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftKeypoint ) ) . sigma as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftKeypoint ) ,
                "::" , stringify ! ( sigma ) ));
}
impl Clone for _VlSiftKeypoint {
    fn clone(&self) -> Self { *self }
}
pub type VlSiftKeypoint = _VlSiftKeypoint;
/** ------------------------------------------------------------------
 ** @brief SIFT filter
 **
 ** This filter implements the SIFT detector and descriptor.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _VlSiftFilt {
    /**< nominal image smoothing. */
    pub sigman: f64,
    /**< smoothing of pyramid base. */
    pub sigma0: f64,
    /**< k-smoothing */
    pub sigmak: f64,
    /**< delta-smoothing. */
    pub dsigma0: f64,
    /**< image width. */
    pub width: ::std::os::raw::c_int,
    /**< image height. */
    pub height: ::std::os::raw::c_int,
    /**< number of octaves. */
    pub O: ::std::os::raw::c_int,
    /**< number of levels per octave. */
    pub S: ::std::os::raw::c_int,
    /**< minimum octave index. */
    pub o_min: ::std::os::raw::c_int,
    /**< minimum level index. */
    pub s_min: ::std::os::raw::c_int,
    /**< maximum level index. */
    pub s_max: ::std::os::raw::c_int,
    /**< current octave. */
    pub o_cur: ::std::os::raw::c_int,
    /**< temporary pixel buffer. */
    pub temp: *mut vl_sift_pix,
    /**< current GSS data. */
    pub octave: *mut vl_sift_pix,
    /**< current DoG data. */
    pub dog: *mut vl_sift_pix,
    /**< current octave width. */
    pub octave_width: ::std::os::raw::c_int,
    /**< current octave height. */
    pub octave_height: ::std::os::raw::c_int,
    /**< current Gaussian filter */
    pub gaussFilter: *mut vl_sift_pix,
    /**< current Gaussian filter std */
    pub gaussFilterSigma: f64,
    /**< current Gaussian filter width */
    pub gaussFilterWidth: vl_size,
    /**< detected keypoints. */
    pub keys: *mut VlSiftKeypoint,
    /**< number of detected keypoints. */
    pub nkeys: ::std::os::raw::c_int,
    /**< size of the keys buffer. */
    pub keys_res: ::std::os::raw::c_int,
    /**< peak threshold. */
    pub peak_thresh: f64,
    /**< edge threshold. */
    pub edge_thresh: f64,
    /**< norm threshold. */
    pub norm_thresh: f64,
    /**< magnification factor. */
    pub magnif: f64,
    /**< size of Gaussian window (in spatial bins) */
    pub windowSize: f64,
    /**< GSS gradient data. */
    pub grad: *mut vl_sift_pix,
    /**< GSS gradient data octave. */
    pub grad_o: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__VlSiftFilt() {
    assert_eq!(::std::mem::size_of::<_VlSiftFilt>() , 192usize , concat ! (
               "Size of: " , stringify ! ( _VlSiftFilt ) ));
    assert_eq! (::std::mem::align_of::<_VlSiftFilt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _VlSiftFilt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . sigman as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( sigman ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . sigma0 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( sigma0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . sigmak as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( sigmak ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . dsigma0 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( dsigma0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . width as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . height as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . O as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( O ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . S as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( S ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . o_min as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( o_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . s_min as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( s_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . s_max as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( s_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . o_cur as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( o_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . temp as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( temp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . octave as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( octave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . dog as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( dog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . octave_width as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( octave_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . octave_height as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( octave_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . gaussFilter as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( gaussFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . gaussFilterSigma as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( gaussFilterSigma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . gaussFilterWidth as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( gaussFilterWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . keys as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( keys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . nkeys as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( nkeys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . keys_res as * const _
                as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( keys_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . peak_thresh as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( peak_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . edge_thresh as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( edge_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . norm_thresh as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( norm_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . magnif as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( magnif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . windowSize as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( windowSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . grad as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( grad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _VlSiftFilt ) ) . grad_o as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _VlSiftFilt ) , "::" ,
                stringify ! ( grad_o ) ));
}
impl Clone for _VlSiftFilt {
    fn clone(&self) -> Self { *self }
}
pub type VlSiftFilt = _VlSiftFilt;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_sift_new(width: ::std::os::raw::c_int,
                       height: ::std::os::raw::c_int,
                       noctaves: ::std::os::raw::c_int,
                       nlevels: ::std::os::raw::c_int,
                       o_min: ::std::os::raw::c_int) -> *mut VlSiftFilt;
}
extern "C" {
    pub fn vl_sift_delete(f: *mut VlSiftFilt);
}
extern "C" {
    /** @name Process data
 ** @{
 **/
    pub fn vl_sift_process_first_octave(f: *mut VlSiftFilt,
                                        im: *const vl_sift_pix)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_sift_process_next_octave(f: *mut VlSiftFilt)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_sift_detect(f: *mut VlSiftFilt);
}
extern "C" {
    pub fn vl_sift_calc_keypoint_orientations(f: *mut VlSiftFilt,
                                              angles: *mut f64,
                                              k: *const VlSiftKeypoint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vl_sift_calc_keypoint_descriptor(f: *mut VlSiftFilt,
                                            descr: *mut vl_sift_pix,
                                            k: *const VlSiftKeypoint,
                                            angle: f64);
}
extern "C" {
    pub fn vl_sift_calc_raw_descriptor(f: *const VlSiftFilt,
                                       image: *const vl_sift_pix,
                                       descr: *mut vl_sift_pix,
                                       widht: ::std::os::raw::c_int,
                                       height: ::std::os::raw::c_int, x: f64,
                                       y: f64, s: f64, angle0: f64);
}
extern "C" {
    pub fn vl_sift_keypoint_init(f: *const VlSiftFilt, k: *mut VlSiftKeypoint,
                                 x: f64, y: f64, sigma: f64);
}
extern "C" {
    pub fn vl_slic_segment(segmentation: *mut vl_uint32, image: *const f32,
                           width: vl_size, height: vl_size,
                           numChannels: vl_size, regionSize: vl_size,
                           regularization: f32, minRegionSize: vl_size);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VlSvm_([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VlSvmDataset_([u8; 0]);
pub type VlSvmDataset = VlSvmDataset_;
/** @name SVM callbacks
 ** @{ */
pub type VlSvmDiagnosticFunction =
    ::std::option::Option<unsafe extern "C" fn(svm: *mut VlSvm_,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
pub type VlSvmLossFunction =
    ::std::option::Option<unsafe extern "C" fn(inner: f64, label: f64)
                              -> f64>;
pub type VlSvmDcaUpdateFunction =
    ::std::option::Option<unsafe extern "C" fn(alpha: f64, inner: f64,
                                               norm2: f64, label: f64)
                              -> f64>;
pub type VlSvmInnerProductFunction =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *const ::std::os::raw::c_void,
                                               element: vl_uindex,
                                               model: *mut f64) -> f64>;
pub type VlSvmAccumulateFunction =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *const ::std::os::raw::c_void,
                                               element: vl_uindex,
                                               model: *mut f64,
                                               multiplier: f64)>;
extern "C" {
    /** @name Create and destroy
 ** @{
 **/
    pub fn vl_svmdataset_new(dataType: vl_type,
                             data: *mut ::std::os::raw::c_void,
                             dimension: vl_size, numData: vl_size)
     -> *mut VlSvmDataset;
}
extern "C" {
    pub fn vl_svmdataset_delete(dataset: *mut VlSvmDataset);
}
extern "C" {
    /** @name Set parameters
 ** @{
 **/
    pub fn vl_svmdataset_set_homogeneous_kernel_map(self_: *mut VlSvmDataset,
                                                    hom:
                                                        *mut VlHomogeneousKernelMap);
}
extern "C" {
    /** @name Get data and parameters
 ** @{
 **/
    pub fn vl_svmdataset_get_data(self_: *const VlSvmDataset)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_svmdataset_get_num_data(self_: *const VlSvmDataset) -> vl_size;
}
extern "C" {
    pub fn vl_svmdataset_get_dimension(self_: *const VlSvmDataset) -> vl_size;
}
extern "C" {
    pub fn vl_svmdataset_get_map(self_: *const VlSvmDataset)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vl_svmdataset_get_mapDim(self_: *const VlSvmDataset) -> vl_size;
}
extern "C" {
    pub fn vl_svmdataset_get_accumulate_function(self_: *const VlSvmDataset)
     -> VlSvmAccumulateFunction;
}
extern "C" {
    pub fn vl_svmdataset_get_inner_product_function(self_:
                                                        *const VlSvmDataset)
     -> VlSvmInnerProductFunction;
}
extern "C" {
    pub fn vl_svmdataset_get_homogeneous_kernel_map(self_:
                                                        *const VlSvmDataset)
     -> *mut VlHomogeneousKernelMap;
}
pub type VlSvm = VlSvm_;
#[repr(u32)]
/** @brief Type of SVM solver */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlSvmSolverType {
    VlSvmSolverNone = 0,
    VlSvmSolverSgd = 1,
    VlSvmSolverSdca = 2,
}
#[repr(u32)]
/** @brief Type of SVM loss
 **
 ** Default SVM loss types. The loss can be set by using ::vl_svm_set_loss.
 ** Note that custom losses can be used too by using ::vl_svm_set_loss_function,
 ** ::vl_svm_set_loss_derivative_function, etc.
 **
 ** @sa svm-loss-functions
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlSvmLossType {
    VlSvmLossHinge = 0,
    VlSvmLossHinge2 = 1,
    VlSvmLossL1 = 2,
    VlSvmLossL2 = 3,
    VlSvmLossLogistic = 4,
}
#[repr(u32)]
/** @brief Solver status */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VlSvmSolverStatus {
    VlSvmStatusTraining = 1,
    VlSvmStatusConverged = 2,
    VlSvmStatusMaxNumIterationsReached = 3,
}
/** @brief SVM statistics
 ** This structure contains statistics characterising the state of
 ** the SVM solver, such as the current value of the objective function.
 **
 ** Not all fields are used by all solvers.
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VlSvmStatistics_ {
    /**< Solver status. */
    pub status: VlSvmSolverStatus,
    /**< Solver iteration. */
    pub iteration: vl_size,
    /**< Solver epoch (iteration / num samples). */
    pub epoch: vl_size,
    /**< Objective function value. */
    pub objective: f64,
    /**< Regularizer value. */
    pub regularizer: f64,
    /**< Loss value. */
    pub loss: f64,
    /**< Dual objective value. */
    pub dualObjective: f64,
    /**< Dual loss value. */
    pub dualLoss: f64,
    /**< Duality gap = objective - dualObjective. */
    pub dualityGap: f64,
    /**< Variance of the score updates. */
    pub scoresVariation: f64,
    /**< Time elapsed from the start of training. */
    pub elapsedTime: f64,
}
#[test]
fn bindgen_test_layout_VlSvmStatistics_() {
    assert_eq!(::std::mem::size_of::<VlSvmStatistics_>() , 88usize , concat !
               ( "Size of: " , stringify ! ( VlSvmStatistics_ ) ));
    assert_eq! (::std::mem::align_of::<VlSvmStatistics_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VlSvmStatistics_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . status as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . iteration as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( iteration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . epoch as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . objective as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( objective ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . regularizer as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( regularizer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . loss as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( loss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . dualObjective as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( dualObjective ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . dualLoss as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( dualLoss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . dualityGap as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( dualityGap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . scoresVariation as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( scoresVariation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VlSvmStatistics_ ) ) . elapsedTime as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( VlSvmStatistics_ ) ,
                "::" , stringify ! ( elapsedTime ) ));
}
impl Clone for VlSvmStatistics_ {
    fn clone(&self) -> Self { *self }
}
pub type VlSvmStatistics = VlSvmStatistics_;
extern "C" {
    /** @name Create and destroy
 ** @{ */
    pub fn vl_svm_new(type_: VlSvmSolverType, data: *const f64,
                      dimension: vl_size, numData: vl_size,
                      labels: *const f64, lambda: f64) -> *mut VlSvm;
}
extern "C" {
    pub fn vl_svm_new_with_dataset(type_: VlSvmSolverType,
                                   dataset: *mut VlSvmDataset,
                                   labels: *const f64, lambda: f64)
     -> *mut VlSvm;
}
extern "C" {
    pub fn vl_svm_new_with_abstract_data(type_: VlSvmSolverType,
                                         data: *mut ::std::os::raw::c_void,
                                         dimension: vl_size, numData: vl_size,
                                         labels: *const f64, lambda: f64)
     -> *mut VlSvm;
}
extern "C" {
    pub fn vl_svm_delete(self_: *mut VlSvm);
}
extern "C" {
    /** @name Retrieve parameters and data
 ** @{ */
    pub fn vl_svm_get_statistics(self_: *const VlSvm)
     -> *const VlSvmStatistics;
}
extern "C" {
    pub fn vl_svm_get_model(self_: *const VlSvm) -> *const f64;
}
extern "C" {
    pub fn vl_svm_get_bias(self_: *const VlSvm) -> f64;
}
extern "C" {
    pub fn vl_svm_get_dimension(self_: *mut VlSvm) -> vl_size;
}
extern "C" {
    pub fn vl_svm_get_num_data(self_: *mut VlSvm) -> vl_size;
}
extern "C" {
    pub fn vl_svm_get_epsilon(self_: *const VlSvm) -> f64;
}
extern "C" {
    pub fn vl_svm_get_bias_learning_rate(self_: *const VlSvm) -> f64;
}
extern "C" {
    pub fn vl_svm_get_max_num_iterations(self_: *const VlSvm) -> vl_size;
}
extern "C" {
    pub fn vl_svm_get_diagnostic_frequency(self_: *const VlSvm) -> vl_size;
}
extern "C" {
    pub fn vl_svm_get_solver(self_: *const VlSvm) -> VlSvmSolverType;
}
extern "C" {
    pub fn vl_svm_get_bias_multiplier(self_: *const VlSvm) -> f64;
}
extern "C" {
    pub fn vl_svm_get_lambda(self_: *const VlSvm) -> f64;
}
extern "C" {
    pub fn vl_svm_get_iteration_number(self_: *const VlSvm) -> vl_size;
}
extern "C" {
    pub fn vl_svm_get_scores(self_: *const VlSvm) -> *const f64;
}
extern "C" {
    pub fn vl_svm_get_weights(self_: *const VlSvm) -> *const f64;
}
extern "C" {
    /** @name Set parameters
 ** @{ */
    pub fn vl_svm_set_epsilon(self_: *mut VlSvm, epsilon: f64);
}
extern "C" {
    pub fn vl_svm_set_bias_learning_rate(self_: *mut VlSvm, rate: f64);
}
extern "C" {
    pub fn vl_svm_set_max_num_iterations(self_: *mut VlSvm,
                                         maxNumIterations: vl_size);
}
extern "C" {
    pub fn vl_svm_set_diagnostic_frequency(self_: *mut VlSvm, f: vl_size);
}
extern "C" {
    pub fn vl_svm_set_bias_multiplier(self_: *mut VlSvm, b: f64);
}
extern "C" {
    pub fn vl_svm_set_model(self_: *mut VlSvm, model: *const f64);
}
extern "C" {
    pub fn vl_svm_set_bias(self_: *mut VlSvm, b: f64);
}
extern "C" {
    pub fn vl_svm_set_iteration_number(self_: *mut VlSvm, n: vl_uindex);
}
extern "C" {
    pub fn vl_svm_set_weights(self_: *mut VlSvm, weights: *const f64);
}
extern "C" {
    pub fn vl_svm_set_diagnostic_function(self_: *mut VlSvm,
                                          f: VlSvmDiagnosticFunction,
                                          data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vl_svm_set_loss_function(self_: *mut VlSvm, f: VlSvmLossFunction);
}
extern "C" {
    pub fn vl_svm_set_loss_derivative_function(self_: *mut VlSvm,
                                               f: VlSvmLossFunction);
}
extern "C" {
    pub fn vl_svm_set_conjugate_loss_function(self_: *mut VlSvm,
                                              f: VlSvmLossFunction);
}
extern "C" {
    pub fn vl_svm_set_dca_update_function(self_: *mut VlSvm,
                                          f: VlSvmDcaUpdateFunction);
}
extern "C" {
    pub fn vl_svm_set_data_functions(self_: *mut VlSvm,
                                     inner: VlSvmInnerProductFunction,
                                     acc: VlSvmAccumulateFunction);
}
extern "C" {
    pub fn vl_svm_set_loss(self_: *mut VlSvm, loss: VlSvmLossType);
}
extern "C" {
    /** @name Process data
 ** @{ */
    pub fn vl_svm_train(self_: *mut VlSvm);
}
extern "C" {
    /** @name Loss functions
 ** @sa @ref svm-advanced
 ** @{ */
    pub fn vl_svm_hinge_loss(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge_loss_derivative(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge_conjugate_loss(label: f64, u: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge_dca_update(alpha: f64, inner: f64, norm2: f64,
                                   label: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge2_loss(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge2_loss_derivative(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge2_conjugate_loss(label: f64, u: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_hinge2_dca_update(alpha: f64, inner: f64, norm2: f64,
                                    label: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l1_loss(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l1_loss_derivative(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l1_conjugate_loss(label: f64, u: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l1_dca_update(alpha: f64, inner: f64, norm2: f64,
                                label: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l2_loss(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l2_loss_derivative(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l2_conjugate_loss(label: f64, u: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_l2_dca_update(alpha: f64, inner: f64, norm2: f64,
                                label: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_logistic_loss(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_logistic_loss_derivative(label: f64, inner: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_logistic_conjugate_loss(label: f64, u: f64) -> f64;
}
extern "C" {
    pub fn vl_svm_logistic_dca_update(alpha: f64, inner: f64, norm2: f64,
                                      label: f64) -> f64;
}
extern "C" {
    /** @def VL_VLAD_FLAG_NORMALIZE_MASS
 ** @brief Normalize each component by the number of features assigned to it.
 **/
/** @} */
    pub fn vl_vlad_encode(enc: *mut ::std::os::raw::c_void, dataType: vl_type,
                          means: *const ::std::os::raw::c_void,
                          dimension: vl_size, numClusters: vl_size,
                          data: *const ::std::os::raw::c_void,
                          numData: vl_size,
                          assignments: *const ::std::os::raw::c_void,
                          flags: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
